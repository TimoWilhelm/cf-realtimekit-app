// This file is auto-generated by @hey-api/openapi-ts

export type LivestreamBase = {
    /**
     * The status of the livestream.
     */
    status?: 'LIVE' | 'IDLE' | 'ERRORED' | 'INVOKED';
    /**
     * Name of the livestream.
     */
    name?: string | null;
    /**
     * ID of the meeting.
     */
    meeting_id?: string | null;
    /**
     * The server URL to which the RTMP encoder sends the video and audio data.
     */
    ingest_server?: string;
    /**
     * The livestream ID.
     */
    id?: string;
    /**
     * Unique key for accessing each livestream.
     */
    stream_key?: string;
    /**
     * The web address that viewers can use to watch the livestream.
     */
    playback_url?: string;
    /**
     * The timestamp at which the livestream was created. The time is returned in ISO format.
     */
    created_at?: string;
    /**
     * The timestamp at which the livestream was updated. The time is returned in ISO format.
     */
    updated_at?: string;
    /**
     * Specifies if the livestream was disabled.
     */
    disabled?: boolean;
    org_id?: string;
};

export type Success = boolean;

export type WebhooksListSuccessResponseReadable = {
    success: boolean;
    data: Array<WebhookReadable>;
};

export type WebhooksListSuccessResponseWritable = {
    success: boolean;
    data: Array<WebhookWritable>;
};

export type WebhookReadable = {
    /**
     * ID of the webhook
     */
    readonly id: string;
    /**
     * Name of the webhook
     */
    name: string;
    /**
     * URL the webhook will send events to
     */
    url: string;
    /**
     * Events this webhook will send updates for
     */
    events: Array<'meeting.started' | 'meeting.ended' | 'meeting.participantJoined' | 'meeting.participantLeft' | 'meeting.chatSynced' | 'recording.statusUpdate' | 'livestreaming.statusUpdate' | 'meeting.transcript' | 'meeting.summary'>;
    /**
     * Timestamp when this webhook was created
     */
    created_at: string;
    /**
     * Timestamp when this webhook was updated
     */
    updated_at: string;
    /**
     * Set to true if the webhook is active
     */
    enabled: boolean;
};

export type WebhookWritable = {
    /**
     * Name of the webhook
     */
    name: string;
    /**
     * URL the webhook will send events to
     */
    url: string;
    /**
     * Events this webhook will send updates for
     */
    events: Array<'meeting.started' | 'meeting.ended' | 'meeting.participantJoined' | 'meeting.participantLeft' | 'meeting.chatSynced' | 'recording.statusUpdate' | 'livestreaming.statusUpdate' | 'meeting.transcript' | 'meeting.summary'>;
    /**
     * Timestamp when this webhook was created
     */
    created_at: string;
    /**
     * Timestamp when this webhook was updated
     */
    updated_at: string;
    /**
     * Set to true if the webhook is active
     */
    enabled: boolean;
};

export type WebhookRequest = {
    /**
     * Name of the webhook
     */
    name: string;
    /**
     * URL this webhook will send events to
     */
    url: string;
    /**
     * Events that this webhook will get triggered by
     */
    events: Array<'meeting.started' | 'meeting.ended' | 'meeting.participantJoined' | 'meeting.participantLeft' | 'meeting.chatSynced' | 'recording.statusUpdate' | 'livestreaming.statusUpdate' | 'meeting.transcript' | 'meeting.summary'>;
    /**
     * Set whether or not the webhook should be active when created
     */
    enabled?: boolean;
};

export type WebhookSuccessResponseReadable = {
    success: boolean;
    data: WebhookReadable;
};

export type WebhookSuccessResponseWritable = {
    success: boolean;
    data: WebhookWritable;
};

export type ErrorResponse = {
    /**
     * Whether the operation succeeded or not
     */
    success: boolean;
    /**
     * Object containing details of the error that occurred
     */
    error: {
        /**
         * Error code
         */
        code: number;
        /**
         * Error message
         */
        message: string;
    };
};

export type PatchWebhookRequest = {
    /**
     * Name of the webhook
     */
    name?: string;
    /**
     * URL the webhook will send events to
     */
    url?: string;
    /**
     * Events that the webhook will get triggered by
     */
    events?: Array<'meeting.started' | 'meeting.ended' | 'meeting.participantJoined' | 'meeting.participantLeft' | 'recording.statusUpdate' | 'livestreaming.statusUpdate' | 'meeting.chatSynced' | 'meeting.transcript' | 'meeting.summary'>;
    enabled?: boolean;
};

export type OrganizationListSuccessResponse = {
    success: boolean;
    data: Array<OrganizationData>;
    paging: {
        total_count: number;
        start_offset: number;
        end_offset: number;
    };
};

export type OrganizationData = {
    /**
     * ID of the organization
     */
    id: string;
    /**
     * Must be a unique organization name
     */
    name: string;
    contact: string;
    website: string;
    apikey: string;
    preferred_region: string;
    feature_flags: Array<string>;
    created_at: string;
    updated_at: string;
};

export type OrganizationRequest = {
    /**
     * Must be a unique organization name
     */
    name: string;
    contact: string;
    website: string;
    feature_flags?: Array<string>;
    preferred_region?: 'ap-south-1' | 'ap-southeast-1' | 'us-east-1' | 'eu-central-1';
};

export type OrganizationSuccessResponse = {
    success: boolean;
    data: OrganizationData;
};

export type PatchOrganizationRequest = {
    /**
     * Must be a unique organization name
     */
    name?: string;
    contact?: string;
    website?: string;
    feature_flags?: Array<string>;
    preferred_region?: 'ap-south-1' | 'ap-southeast-1' | 'us-east-1' | 'eu-central-1';
};

export type CreateChatChannelInfo = {
    display_name?: string;
    custom_participant_ids?: Array<string>;
    visibility?: 'public' | 'private';
};

/**
 * RecordingConfig
 * Recording Configurations to be used for this meeting. This level of configs takes higher preference over organization level configs on the RealtimeKit developer portal.
 *
 */
export type RecordingConfigReadable = {
    /**
     * Specifies the maximum duration for recording in seconds, ranging from a minimum of 60 seconds to a maximum of 24 hours.
     */
    max_seconds?: number;
    /**
     * Adds a prefix to the beginning of the file name of the recording.
     */
    file_name_prefix?: string;
    video_config?: VideoConfig;
    audio_config?: AudioConfig;
    storage_config?: StorageConfigReadable;
    realtimekit_bucket_config?: RealtimekitBucketConfig;
    live_streaming_config?: LivestreamingConfig;
};

/**
 * RecordingConfig
 * Recording Configurations to be used for this meeting. This level of configs takes higher preference over organization level configs on the RealtimeKit developer portal.
 *
 */
export type RecordingConfigWritable = {
    /**
     * Specifies the maximum duration for recording in seconds, ranging from a minimum of 60 seconds to a maximum of 24 hours.
     */
    max_seconds?: number;
    /**
     * Adds a prefix to the beginning of the file name of the recording.
     */
    file_name_prefix?: string;
    video_config?: VideoConfig;
    audio_config?: AudioConfig;
    storage_config?: StorageConfigWritable;
    realtimekit_bucket_config?: RealtimekitBucketConfig;
    live_streaming_config?: LivestreamingConfig;
};

/**
 * VideoConfig
 */
export type VideoConfig = {
    /**
     * Codec using which the recording will be encoded.
     */
    codec?: 'H264' | 'VP8';
    /**
     * Width of the recording video in pixels
     */
    width?: number;
    /**
     * Height of the recording video in pixels
     */
    height?: number;
    /**
     * Watermark to be added to the recording
     */
    watermark?: {
        /**
         * URL of the watermark image
         */
        url?: string;
        /**
         * Size of the watermark
         */
        size?: {
            /**
             * Width of the watermark in px
             */
            width?: number;
            /**
             * Height of the watermark in px
             */
            height?: number;
        };
        /**
         * Position of the watermark
         */
        position?: 'left top' | 'right top' | 'left bottom' | 'right bottom';
    };
    /**
     * Controls whether to export video file seperately
     */
    export_file?: boolean;
};

/**
 * AudioConfig
 * Object containing configuration regarding the audio that is being recorded.
 */
export type AudioConfig = {
    /**
     * Codec using which the recording will be encoded. If VP8/VP9 is selected for videoConfig, changing audioConfig is not allowed. In this case, the codec in the audioConfig is automatically set to vorbis.
     */
    codec?: 'MP3' | 'AAC';
    /**
     * Audio signal pathway within an audio file that carries a specific sound source.
     */
    channel?: 'mono' | 'stereo';
    /**
     * Controls whether to export audio file seperately
     */
    export_file?: boolean;
};

/**
 * StorageConfig
 */
export type StorageConfigReadable = {
    /**
     * Type of storage media.
     */
    type: 'aws' | 'azure' | 'digitalocean' | 'gcs' | 'sftp';
    /**
     * Secret key of the storage medium. Similar to `access_key`, it is only writeable by clients, not readable.
     */
    secret?: string;
    /**
     * Name of the storage medium's bucket.
     */
    bucket?: string;
    /**
     * Region of the storage medium.
     */
    region?: string;
    /**
     * Path relative to the bucket root at which the recording will be placed.
     */
    path?: string;
    /**
     * Authentication method used for "sftp" type storage medium
     *
     */
    auth_method?: 'KEY' | 'PASSWORD';
    /**
     * SSH destination server username for SFTP type storage medium
     */
    username?: string;
    /**
     * SSH destination server password for SFTP type storage medium when auth_method is "PASSWORD". If auth_method is "KEY", this specifies the password for the ssh private key.
     */
    password?: string;
    /**
     * SSH destination server host for SFTP type storage medium
     */
    host?: string;
    /**
     * SSH destination server port for SFTP type storage medium
     */
    port?: number;
    /**
     * Private key used to login to destination SSH server for SFTP type storage medium, when auth_method used is "KEY"
     */
    private_key?: string;
} | null;

/**
 * StorageConfig
 */
export type StorageConfigWritable = {
    /**
     * Type of storage media.
     */
    type: 'aws' | 'azure' | 'digitalocean' | 'gcs' | 'sftp';
    /**
     * Access key of the storage medium. Access key is not required for the `gcs` storage media type.
     *
     * Note that this field is not readable by clients, only writeable.
     */
    access_key?: string;
    /**
     * Secret key of the storage medium. Similar to `access_key`, it is only writeable by clients, not readable.
     */
    secret?: string;
    /**
     * Name of the storage medium's bucket.
     */
    bucket?: string;
    /**
     * Region of the storage medium.
     */
    region?: string;
    /**
     * Path relative to the bucket root at which the recording will be placed.
     */
    path?: string;
    /**
     * Authentication method used for "sftp" type storage medium
     *
     */
    auth_method?: 'KEY' | 'PASSWORD';
    /**
     * SSH destination server username for SFTP type storage medium
     */
    username?: string;
    /**
     * SSH destination server password for SFTP type storage medium when auth_method is "PASSWORD". If auth_method is "KEY", this specifies the password for the ssh private key.
     */
    password?: string;
    /**
     * SSH destination server host for SFTP type storage medium
     */
    host?: string;
    /**
     * SSH destination server port for SFTP type storage medium
     */
    port?: number;
    /**
     * Private key used to login to destination SSH server for SFTP type storage medium, when auth_method used is "KEY"
     */
    private_key?: string;
} | null;

/**
 * realtimekitBucketConfig
 */
export type RealtimekitBucketConfig = {
    /**
     * Controls whether recordings are uploaded to RealtimeKit's bucket. If set to false, `download_url`, `audio_download_url`, `download_url_expiry` won't be generated for a recording.
     */
    enabled: boolean;
};

/**
 * LivestreamingConfig
 */
export type LivestreamingConfig = {
    /**
     * RTMP URL to stream to
     */
    rtmp_url?: string;
};

/**
 * AIConfig
 * The AI Config allows you to customize the behavior of meeting transcriptions and summaries
 */
export type AiConfig = {
    transcription?: TranscriptionConfig;
    summarization?: SummarizationConfig;
};

/**
 * TranscriptionConfig
 * Transcription Configurations
 */
export type TranscriptionConfig = {
    /**
     * Adds specific terms to improve accurate detection during transcription.
     */
    keywords?: Array<string>;
    /**
     * Specifies the language code for transcription to ensure accurate results.
     */
    language?: 'en-US' | 'en-IN' | 'de' | 'hi' | 'sv' | 'ru' | 'pl' | 'el' | 'fr' | 'nl';
    /**
     * Control the inclusion of offensive language in transcriptions.
     */
    profanity_filter?: boolean;
};

/**
 * SummarizationConfig
 * Summary Config
 */
export type SummarizationConfig = {
    /**
     * Sets the maximum number of words in the meeting summary.
     */
    word_limit?: number;
    /**
     * Determines the text format of the summary, such as plain text or markdown.
     */
    text_format?: 'plain_text' | 'markdown';
    /**
     * Defines the style of the summary, such as general, team meeting, or sales call.
     */
    summary_type?: 'general' | 'team_meeting' | 'sales_call' | 'client_check_in' | 'interview' | 'daily_standup' | 'one_on_one_meeting' | 'lecture' | 'code_review';
};

/**
 * InteractiveConfig
 * Allows you to add timed metadata to your recordings, which are digital markers inserted into a video file to provide contextual information at specific points in the content range. The ID3 tags containing this information are available to clients on the playback timeline in HLS format. The output files are generated in a compressed .tar format.
 */
export type InteractiveConfig = {
    /**
     * The metadata is presented in the form of ID3 tags.
     */
    type?: 'ID3';
};

/**
 * Preset
 */
export type Preset = {
    /**
     * Name of the preset
     */
    name: string;
    config: {
        /**
         * Type of the meeting
         */
        view_type: 'GROUP_CALL' | 'WEBINAR' | 'AUDIO_ROOM';
        /**
         * Maximum number of streams that are visible on a device
         */
        max_video_streams: {
            /**
             * Maximum number of streams visible on mobile devices
             */
            mobile: number;
            /**
             * Maximum number of video streams visible on desktop devices
             */
            desktop: number;
        };
        /**
         * Maximum number of screen shares that can be active at a given time
         */
        max_screenshare_count: number;
        /**
         * Media configuration options. eg: Video quality
         */
        media: {
            /**
             * Control options for Audio quality.
             */
            audio?: {
                /**
                 * Enable Stereo for your meetings
                 */
                enable_stereo?: boolean;
                /**
                 * Enable High Quality Audio for your meetings
                 */
                enable_high_bitrate?: boolean;
            };
            /**
             * Configuration options for participant videos
             */
            video: {
                /**
                 * Video quality of participants
                 */
                quality: 'hd' | 'vga' | 'qvga';
                /**
                 * Frame rate of participants' video
                 */
                frame_rate: number;
            };
            /**
             * Configuration options for participant screen shares
             */
            screenshare: {
                /**
                 * Quality of screen share
                 */
                quality: 'hd' | 'vga' | 'qvga';
                /**
                 * Frame rate of screen share
                 */
                frame_rate: number;
            };
        };
    };
    permissions?: {
        /**
         * Whether this participant can accept waiting requests
         */
        accept_waiting_requests: boolean;
        can_accept_production_requests: boolean;
        can_edit_display_name: boolean;
        can_spotlight: boolean;
        is_recorder?: boolean;
        /**
         * Type of the recording peer
         */
        recorder_type: 'RECORDER' | 'LIVESTREAMER' | 'NONE';
        disable_participant_audio: boolean;
        disable_participant_screensharing: boolean;
        disable_participant_video: boolean;
        kick_participant: boolean;
        pin_participant: boolean;
        can_record: boolean;
        can_livestream: boolean;
        /**
         * Waiting room type
         */
        waiting_room_type: 'SKIP' | 'ON_PRIVILEGED_USER_ENTRY' | 'SKIP_ON_ACCEPT';
        /**
         * Plugin permissions
         */
        plugins: {
            /**
             * Can close plugins that are already open
             */
            can_close: boolean;
            /**
             * Can start plugins
             */
            can_start: boolean;
            /**
             * Can edit plugin config
             */
            can_edit_config: boolean;
            config: string | {
                access_control: 'FULL_ACCESS' | 'VIEW_ONLY';
                handles_view_only: boolean;
            };
        };
        connected_meetings: {
            can_alter_connected_meetings: boolean;
            can_switch_connected_meetings: boolean;
            can_switch_to_parent_meeting: boolean;
        };
        /**
         * Poll permissions
         */
        polls: {
            /**
             * Can create polls
             */
            can_create: boolean;
            /**
             * Can vote on polls
             */
            can_vote: boolean;
            /**
             * Can view polls
             */
            can_view: boolean;
        };
        /**
         * Media permissions
         */
        media: {
            /**
             * Video permissions
             */
            video: {
                /**
                 * Can produce video
                 */
                can_produce: 'ALLOWED' | 'NOT_ALLOWED' | 'CAN_REQUEST';
            };
            /**
             * Audio permissions
             */
            audio: {
                /**
                 * Can produce audio
                 */
                can_produce: 'ALLOWED' | 'NOT_ALLOWED' | 'CAN_REQUEST';
            };
            /**
             * Screenshare permissions
             */
            screenshare: {
                /**
                 * Can produce screen share video
                 */
                can_produce: 'ALLOWED' | 'NOT_ALLOWED' | 'CAN_REQUEST';
            };
        };
        /**
         * Chat permissions
         */
        chat: {
            public: {
                /**
                 * Can send messages in general
                 */
                can_send: boolean;
                /**
                 * Can send text messages
                 */
                text: boolean;
                /**
                 * Can send file messages
                 */
                files: boolean;
            };
            private: {
                can_send: boolean;
                can_receive: boolean;
                text: boolean;
                files: boolean;
            };
        };
        /**
         * Whether this participant is visible to others or not
         */
        hidden_participant: boolean;
        show_participant_list: boolean;
        can_change_participant_permissions: boolean;
    };
    ui: {
        design_tokens: {
            border_radius: 'rounded';
            border_width: 'thin';
            spacing_base: number;
            theme: 'dark';
            colors: {
                brand: {
                    300: string;
                    400: string;
                    500: string;
                    600: string;
                    700: string;
                };
                background: {
                    600: string;
                    700: string;
                    800: string;
                    900: string;
                    1000: string;
                };
                danger: string;
                text: string;
                text_on_brand: string;
                success: string;
                video_bg: string;
                warning: string;
            };
            logo: string;
        };
        config_diff?: {
            [key: string]: unknown;
        };
    };
};

/**
 * UpdatePreset
 */
export type UpdatePreset = {
    /**
     * Name of the preset
     */
    name?: string;
    config?: {
        /**
         * Type of the meeting
         */
        view_type?: 'GROUP_CALL' | 'WEBINAR' | 'AUDIO_ROOM';
        /**
         * Maximum number of streams that are visible on a device
         */
        max_video_streams?: {
            /**
             * Maximum number of streams visible on mobile devices
             */
            mobile?: number;
            /**
             * Maximum number of video streams visible on desktop devices
             */
            desktop?: number;
        };
        /**
         * Maximum number of screen shares that can be active at a given time
         */
        max_screenshare_count?: number;
        /**
         * Media configuration options. eg: Video quality
         */
        media?: {
            /**
             * Configuration options for participant videos
             */
            video?: {
                /**
                 * Video quality of participants
                 */
                quality?: 'hd' | 'vga' | 'qvga';
                /**
                 * Frame rate of participants' video
                 */
                frame_rate?: number;
            };
            /**
             * Configuration options for participant screen shares
             */
            screenshare?: {
                /**
                 * Quality of screen share
                 */
                quality?: 'hd' | 'vga' | 'qvga';
                /**
                 * Frame rate of screen share
                 */
                frame_rate?: number;
            };
        };
    };
    permissions?: {
        /**
         * Whether this participant can accept waiting requests
         */
        accept_waiting_requests?: boolean;
        can_accept_production_requests?: boolean;
        can_edit_display_name?: boolean;
        can_spotlight?: boolean;
        is_recorder?: boolean;
        /**
         * Type of the recording peer
         */
        recorder_type?: 'RECORDER' | 'LIVESTREAMER' | 'NONE';
        disable_participant_audio?: boolean;
        disable_participant_screensharing?: boolean;
        disable_participant_video?: boolean;
        kick_participant?: boolean;
        pin_participant?: boolean;
        can_record?: boolean;
        can_livestream?: boolean;
        /**
         * Waiting room type
         */
        waiting_room_type?: 'SKIP' | 'ON_PRIVILEGED_USER_ENTRY' | 'SKIP_ON_ACCEPT';
        /**
         * Plugin permissions
         */
        plugins?: {
            /**
             * Can close plugins that are already open
             */
            can_close?: boolean;
            /**
             * Can start plugins
             */
            can_start?: boolean;
            /**
             * Can edit plugin config
             */
            can_edit_config?: boolean;
            config?: string | {
                access_control?: 'FULL_ACCESS' | 'VIEW_ONLY';
                handles_view_only?: boolean;
            };
        };
        connected_meetings?: {
            can_alter_connected_meetings?: boolean;
            can_switch_connected_meetings?: boolean;
            can_switch_to_parent_meeting?: boolean;
        };
        /**
         * Poll permissions
         */
        polls?: {
            /**
             * Can create polls
             */
            can_create?: boolean;
            /**
             * Can vote on polls
             */
            can_vote?: boolean;
            /**
             * Can view polls
             */
            can_view?: boolean;
        };
        /**
         * Media permissions
         */
        media?: {
            /**
             * Video permissions
             */
            video?: {
                /**
                 * Can produce video
                 */
                can_produce?: 'ALLOWED' | 'NOT_ALLOWED' | 'CAN_REQUEST';
            };
            /**
             * Audio permissions
             */
            audio?: {
                /**
                 * Can produce audio
                 */
                can_produce?: 'ALLOWED' | 'NOT_ALLOWED' | 'CAN_REQUEST';
            };
            /**
             * Screenshare permissions
             */
            screenshare?: {
                /**
                 * Can produce screen share video
                 */
                can_produce?: 'ALLOWED' | 'NOT_ALLOWED' | 'CAN_REQUEST';
            };
        };
        /**
         * Chat permissions
         */
        chat?: {
            public?: {
                /**
                 * Can send messages in general
                 */
                can_send?: boolean;
                /**
                 * Can send text messages
                 */
                text?: boolean;
                /**
                 * Can send file messages
                 */
                files?: boolean;
            };
            private?: {
                can_send?: boolean;
                can_receive?: boolean;
                text?: boolean;
                files?: boolean;
            };
        };
        /**
         * Whether this participant is visible to others or not
         */
        hidden_participant?: boolean;
        show_participant_list?: boolean;
        can_change_participant_permissions?: boolean;
    };
    ui?: {
        design_tokens?: {
            border_radius?: 'rounded';
            border_width?: 'thin';
            spacing_base?: number;
            theme?: 'dark';
            colors?: {
                brand?: {
                    300?: string;
                    400?: string;
                    500?: string;
                    600?: string;
                    700?: string;
                };
                background?: {
                    600?: string;
                    700?: string;
                    800?: string;
                    900?: string;
                    1000?: string;
                };
                danger?: string;
                text?: string;
                text_on_brand?: string;
                success?: string;
                video_bg?: string;
                warning?: string;
            };
            logo?: string;
        };
        config_diff?: {
            [key: string]: unknown;
        };
    };
};

/**
 * TrackLayerConfig
 */
export type TrackConfigLayerReadable = {
    /**
     * A file name prefix to apply for files generated from this layer
     */
    file_name_prefix?: string;
    outputs?: Array<TrackLayerOutputReadable>;
};

/**
 * TrackLayerConfig
 */
export type TrackConfigLayerWritable = {
    /**
     * A file name prefix to apply for files generated from this layer
     */
    file_name_prefix?: string;
    outputs?: Array<TrackLayerOutputWritable>;
};

/**
 * TrackLayerOutput
 */
export type TrackLayerOutputReadable = {
    /**
     * The type of output destination this layer is being exported to.
     */
    type?: 'REALTIMEKIT_BUCKET' | 'STORAGE_CONFIG';
    storage_config?: StorageConfigReadable;
};

/**
 * TrackLayerOutput
 */
export type TrackLayerOutputWritable = {
    /**
     * The type of output destination this layer is being exported to.
     */
    type?: 'REALTIMEKIT_BUCKET' | 'STORAGE_CONFIG';
    storage_config?: StorageConfigWritable;
};

export type ActiveSessionReadable = {
    /**
     * ID of the session
     */
    readonly id: string;
    /**
     * ID of the meeting this session is associated with. In the case of V2 meetings, it is always a UUID. In V1 meetings, it is a room name of the form `abcdef-ghijkl`
     */
    associated_id: string;
    /**
     * Title of the meeting this session belongs to
     */
    meeting_display_name: string;
    /**
     * type of session
     */
    type: 'meeting' | 'livestream' | 'participant';
    /**
     * current status of session
     */
    status: 'LIVE' | 'ENDED';
    /**
     * number of participants currently in the session
     */
    live_participants: number;
    /**
     * number of maximum participants that were in the session
     */
    max_concurrent_participants: number;
    /**
     * number of minutes consumed since the session started
     */
    minutes_consumed: number;
    /**
     * Organization id that hosted this session
     */
    organization_id: string;
    /**
     * timestamp when session started
     */
    started_at: string;
    /**
     * timestamp when session created
     */
    created_at: string;
    /**
     * timestamp when session was last updated
     */
    updated_at: string;
    /**
     * timestamp when session ended
     */
    ended_at?: string;
    /**
     * Any meta data about session.
     */
    meta?: {
        [key: string]: unknown;
    };
    readonly breakout_rooms?: Array<ActiveSessionReadable>;
};

export type ActiveSessionWritable = {
    /**
     * ID of the meeting this session is associated with. In the case of V2 meetings, it is always a UUID. In V1 meetings, it is a room name of the form `abcdef-ghijkl`
     */
    associated_id: string;
    /**
     * Title of the meeting this session belongs to
     */
    meeting_display_name: string;
    /**
     * type of session
     */
    type: 'meeting' | 'livestream' | 'participant';
    /**
     * current status of session
     */
    status: 'LIVE' | 'ENDED';
    /**
     * number of participants currently in the session
     */
    live_participants: number;
    /**
     * number of maximum participants that were in the session
     */
    max_concurrent_participants: number;
    /**
     * number of minutes consumed since the session started
     */
    minutes_consumed: number;
    /**
     * Organization id that hosted this session
     */
    organization_id: string;
    /**
     * timestamp when session started
     */
    started_at: string;
    /**
     * timestamp when session created
     */
    created_at: string;
    /**
     * timestamp when session was last updated
     */
    updated_at: string;
    /**
     * timestamp when session ended
     */
    ended_at?: string;
    /**
     * Any meta data about session.
     */
    meta?: {
        [key: string]: unknown;
    };
};

export type GenericErrorResponse = {
    /**
     * Success status of the request.
     */
    success: boolean;
    error: {
        /**
         * HTTP status code of the error.
         */
        code: number;
        /**
         * Error message describing what went wrong.
         */
        message: string;
    };
};

/**
 * SessionParticipant
 */
export type SessionParticipant = {
    /**
     * ID of the session participant
     */
    id: string;
    created_at: string;
    updated_at: string;
    /**
     * Name of the session participant.
     */
    name?: string;
    /**
     * Email of the session participant.
     */
    email?: string;
    /**
     * A URL pointing to a picture of the participant.
     */
    picture?: string;
};

export type PollReadable = {
    /**
     * ID of the poll
     */
    readonly id: string;
    /**
     * Question asked by the poll
     */
    question: string;
    /**
     * Answer options
     */
    options: Array<{
        /**
         * Text of the answer option
         */
        text: string;
        count: number;
        votes: Array<{
            id: string;
            name: string;
        }>;
    }>;
    anonymous?: boolean;
    hide_votes?: boolean;
    created_by?: string;
    voted?: Array<string>;
};

export type PollWritable = {
    /**
     * Question asked by the poll
     */
    question: string;
    /**
     * Answer options
     */
    options: Array<{
        /**
         * Text of the answer option
         */
        text: string;
        count: number;
        votes: Array<{
            id: string;
            name: string;
        }>;
    }>;
    anonymous?: boolean;
    hide_votes?: boolean;
    created_by?: string;
    voted?: Array<string>;
};

export type ParticipantsList = {
    /**
     * Participant ID. This maps to the corresponding peerId.
     */
    id?: string;
    /**
     * User id for this participant.
     */
    user_id?: string;
    /**
     * ID passed by client to create this participant.
     */
    custom_participant_id?: string;
    /**
     * Display name of participant when joining the session.
     */
    display_name?: string;
    /**
     * Name of the preset associated with the participant.
     */
    preset_name?: string;
    /**
     * timestamp at which participant joined the session.
     */
    joined_at?: string;
    /**
     * timestamp at which participant left the session.
     */
    left_at?: string;
    /**
     * number of minutes for which the participant was in the session.
     */
    duration?: number;
    /**
     * timestamp when this participant was created.
     */
    created_at?: string;
    /**
     * timestamp when this participant's data was last updated.
     */
    updated_at?: string;
};

export type ParticipantPeerStats = {
    peer_stats?: {
        config?: string;
        status?: string;
        device_info?: {
            browser?: string;
            browser_version?: string;
            cpus?: number;
            engine?: string;
            is_mobile?: boolean;
            memory?: number;
            os?: string;
            os_version?: string;
            sdk_name?: string;
            sdk_version?: string;
            user_agent?: string;
            webgl_support?: string;
        };
        events?: Array<{
            timestamp?: string;
            type?: string;
        }>;
        ip_information?: {
            city?: string;
            country?: string;
            ip_location?: string;
            ipv4?: string;
            org?: string;
            portal?: string;
            region?: string;
            timezone?: string;
        };
        precall_network_information?: {
            backend_rtt?: number;
            turn_connectivity?: boolean;
            effective_networktype?: string;
            throughtput?: number;
            jitter?: number;
            rtt?: number;
            reflexive_connectivity?: boolean;
            relay_connectivity?: boolean;
            fractional_loss?: number;
        };
    };
};

export type ParticipantQualityStats = {
    quality_stats?: Array<{
        peer_id?: string;
        audio_bandwidth?: number;
        video_bandwidth?: number;
        average_quality?: number;
        start?: string;
        end?: string;
        audio_packet_loss?: number;
        video_packet_loss?: number;
        audio_stats?: Array<{
            timestamp?: string;
            concealment_events?: number;
            packets_lost?: number;
            jitter?: number;
            quality?: number;
        }>;
        video_stats?: Array<{
            timestamp?: string;
            frame_width?: number;
            frame_height?: number;
            frames_dropped?: number;
            frames_per_second?: number;
            packets_lost?: number;
            jitter?: number;
            quality?: number;
        }>;
    }>;
};

export type ChatMessage = {
    /**
     * URL where the chat logs can be downloaded
     */
    chat_download_url: string;
    /**
     * Time when the download URL will expire
     */
    chat_download_url_expiry: string;
};

export type Transcript = {
    sessionId: string;
    /**
     * URL where the transcript can be downloaded
     */
    transcript_download_url: string;
    /**
     * Time when the download URL will expire
     */
    transcript_download_url_expiry: string;
};

export type OverallStats = {
    /**
     * Number of sessions_count happened in the given time period
     */
    sessions_count?: number;
    /**
     * Total meetings minutes consumed across all sessions in the given time period.
     */
    sessions_minutes_consumed?: number;
    /**
     * Total recordings minutes consumed across all sessions in the given time period.
     */
    recordings_minutes_consumed?: number;
};

export type DaywiseStats = {
    /**
     * Date in YYYY-MM-DD format
     */
    date?: string;
    /**
     * Number of sessions_count happened in the given time period
     */
    sessions_count?: number;
    /**
     * Total meetings minutes consumed across all sessions in the given time period.
     */
    sessions_minutes_consumed?: number;
    /**
     * Total recordings minutes consumed across all sessions in the given time period.
     */
    recordings_minutes_consumed?: number;
};

/**
 * GenericSuccessResponse
 */
export type GenericSuccessResponse = {
    /**
     * Success status of the operation
     */
    success: boolean;
    /**
     * Data returned by the operation
     */
    data?: {
        [key: string]: unknown;
    };
};

export type MeetingReadable = {
    /**
     * ID of the meeting.
     */
    readonly id: string;
    /**
     * Title of the meeting.
     */
    title?: string;
    /**
     * The region in which this meeting should be created.
     */
    preferred_region?: 'ap-south-1' | 'ap-southeast-1' | 'us-east-1' | 'eu-central-1' | null;
    /**
     * Timestamp the object was created at. The time is returned in ISO format.
     */
    readonly created_at: string;
    /**
     * Specifies if the meeting should start getting recorded as soon as someone joins the meeting.
     */
    record_on_start?: boolean;
    /**
     * Timestamp the object was updated at. The time is returned in ISO format.
     */
    readonly updated_at: string;
    /**
     * Specifies if the meeting should start getting livestreamed on start.
     */
    live_stream_on_start?: boolean;
    /**
     * Specifies if Chat within a meeting should persist for a week.
     */
    persist_chat?: boolean;
    /**
     * Automatically generate summary of meetings using transcripts. Requires Transcriptions to be enabled, and can be retrieved via Webhooks or summary API.
     */
    summarize_on_end?: boolean;
    /**
     * Whether the meeting is `ACTIVE` or `INACTIVE`. Users will not be able to join an `INACTIVE` meeting.
     */
    status?: 'ACTIVE' | 'INACTIVE';
};

export type MeetingWritable = {
    /**
     * Title of the meeting.
     */
    title?: string;
    /**
     * The region in which this meeting should be created.
     */
    preferred_region?: 'ap-south-1' | 'ap-southeast-1' | 'us-east-1' | 'eu-central-1' | null;
    /**
     * Specifies if the meeting should start getting recorded as soon as someone joins the meeting.
     */
    record_on_start?: boolean;
    /**
     * Specifies if the meeting should start getting livestreamed on start.
     */
    live_stream_on_start?: boolean;
    /**
     * Specifies if Chat within a meeting should persist for a week.
     */
    persist_chat?: boolean;
    /**
     * Automatically generate summary of meetings using transcripts. Requires Transcriptions to be enabled, and can be retrieved via Webhooks or summary API.
     */
    summarize_on_end?: boolean;
    /**
     * Whether the meeting is `ACTIVE` or `INACTIVE`. Users will not be able to join an `INACTIVE` meeting.
     */
    status?: 'ACTIVE' | 'INACTIVE';
};

/**
 * PagingResponse
 */
export type PagingResponse = {
    success: boolean;
    data: Array<unknown>;
    paging: {
        total_count: number;
        start_offset: number;
        end_offset: number;
    };
};

/**
 * Participant
 * Represents a participant.
 */
export type Participant = {
    /**
     * ID of the participant.
     */
    id: string;
    /**
     * Name of the participant.
     */
    name?: string | null;
    /**
     * URL to a picture of the participant.
     */
    picture?: string | null;
    /**
     * A unique participant ID generated by the client.
     */
    custom_participant_id: string;
    /**
     * Preset applied to the participant.
     */
    preset_name: string;
    /**
     * When this object was created. The time is returned in ISO format.
     */
    created_at: string;
    /**
     * When this object was updated. The time is returned in ISO format.
     */
    updated_at: string;
};

/**
 * Recording
 */
export type RecordingReadable = {
    /**
     * ID of the recording
     */
    readonly id: string;
    /**
     * URL where the recording can be downloaded.
     */
    readonly download_url: string | null;
    /**
     * Timestamp when the download URL expires.
     */
    readonly download_url_expiry: string | null;
    /**
     * If the audio_config is passed, the URL for downloading the audio recording is returned.
     */
    readonly audio_download_url: string | null;
    /**
     * File size of the recording, in bytes.
     */
    readonly file_size: number | null;
    /**
     * ID of the meeting session this recording is for.
     */
    readonly session_id: string | null;
    /**
     * File name of the recording.
     */
    output_file_name: string;
    /**
     * Current status of the recording.
     */
    status: 'INVOKED' | 'RECORDING' | 'UPLOADING' | 'UPLOADED' | 'ERRORED' | 'PAUSED';
    /**
     * Timestamp when this recording was invoked.
     */
    invoked_time: string;
    /**
     * Timestamp when this recording actually started after being invoked. Usually a few seconds after `invoked_time`.
     */
    started_time: string | null;
    /**
     * Timestamp when this recording was stopped. Optional; is present only when the recording has actually been stopped.
     */
    stopped_time: string | null;
    /**
     * Total recording time in seconds.
     */
    recording_duration?: number;
};

/**
 * Recording
 */
export type RecordingWritable = {
    /**
     * File name of the recording.
     */
    output_file_name: string;
    /**
     * Current status of the recording.
     */
    status: 'INVOKED' | 'RECORDING' | 'UPLOADING' | 'UPLOADED' | 'ERRORED' | 'PAUSED';
    /**
     * Timestamp when this recording was invoked.
     */
    invoked_time: string;
    /**
     * Timestamp when this recording actually started after being invoked. Usually a few seconds after `invoked_time`.
     */
    started_time: string | null;
    /**
     * Timestamp when this recording was stopped. Optional; is present only when the recording has actually been stopped.
     */
    stopped_time: string | null;
    /**
     * Total recording time in seconds.
     */
    recording_duration?: number;
};

/**
 * startReason
 */
export type StartReason = {
    /**
     * Specifies if the recording was started using the "Start a Recording"API or using the parameter RECORD_ON_START in the "Create a meeting" API.
     *
     * If the recording is initiated using the "RECORD_ON_START" parameter, the user details will not be populated.
     */
    reason?: 'API_CALL' | 'RECORD_ON_START';
    caller?: {
        /**
         * The type can be an organization or a user. If the type is `user`, then only the `user_Id` and `name` are returned.
         */
        type?: 'ORGANIZATION' | 'USER';
        /**
         * The user ID of the person who started the recording.
         */
        user_Id?: string;
        /**
         * Name of the user who started the recording.
         */
        name?: string;
    };
};

/**
 * stopReason
 */
export type StopReason = {
    /**
     * Specifies the reason why the recording stopped.
     */
    reason?: 'API_CALL' | 'INTERNAL_ERROR' | 'ALL_PEERS_LEFT';
    caller?: {
        /**
         * The type can be an organization or a user. If the type is `user`, then only the `user_Id` and `name` are returned.
         */
        type?: 'ORGANIZATION' | 'USER';
        /**
         * The user ID of the person who stopped the recording.
         */
        user_Id?: string;
        /**
         * Name of the user who stopped the recording.
         */
        name?: string;
    };
};

/**
 * PresetListItem
 * Returned by Get All Presets route
 */
export type PresetListItem = {
    /**
     * ID of the preset
     */
    id?: string;
    /**
     * Name of the preset
     */
    name?: string;
    /**
     * Timestamp this preset was created at
     */
    created_at?: string;
    /**
     * Timestamp this preset was last updated
     */
    updated_at?: string;
};

/**
 * TranscriptSummary
 */
export type TranscriptSummary = {
    sessionId: string;
    /**
     * URL where the summary of transcripts can be downloaded
     */
    summaryDownloadUrl: string;
    /**
     * Time of Expiry before when you need to download the csv file.
     */
    summaryDownloadUrlExpiry: string;
};

/**
 * The page number from which you want your page search results to be displayed.
 */
export type PageNo = number;

/**
 * Number of results per page
 */
export type PerPage = number;

/**
 * The search query string. You can search using the meeting ID or title.
 */
export type Search = string;

export type SortBy = 'minutesConsumed' | 'createdAt';

export type SortOrder = 'ASC' | 'DESC';

/**
 * The start time range for which you want to retrieve the meetings. The time must be specified in ISO format.
 */
export type StartTime = string;

/**
 * The end time range for which you want to retrieve the meetings. The time must be specified in ISO format.
 */
export type EndTime = string;

export type Participants = string;

export type Status = 'LIVE' | 'ENDED';

/**
 * Filter by one or more recording status
 */
export type RecordingStatus = Array<'INVOKED' | 'RECORDING' | 'UPLOADING' | 'UPLOADED'>;

export type RecordingSortBy = 'invokedTime';

export type ParticipantsSortBy = 'joinedAt' | 'duration';

/**
 * start date in YYYY-MM-DD format
 */
export type StartDate = string;

/**
 * end date in YYYY-MM-DD format
 */
export type EndDate = string;

/**
 * ID of the livestream
 */
export type StreamId = number;

/**
 * ID of the meeting
 */
export type MeetingId = string;

/**
 * ID of the session
 */
export type SessionId = string;

/**
 * ID of the participant
 */
export type ParticipantId = string;

/**
 * Request body for kicking participants from an active session. Only one of `participant_id` or `custom_participant_id` is required.
 */
export type KickParticipantsBody = {
    participant_ids?: Array<string>;
    custom_participant_ids?: Array<string>;
};

/**
 * Request body for muting all participants in an active session.
 */
export type MuteAllParticipantsBody = {
    /**
     * if false, participants won't be able to unmute themselves after they are muted
     */
    allow_unmute?: boolean;
};

/**
 * Request body for creating a new poll
 */
export type CreatePollBody = {
    /**
     * Question of the poll
     */
    question?: string;
    /**
     * Different options for the question
     */
    options?: Array<string>;
    /**
     * if voters on a poll are anonymous
     */
    anonymous?: boolean;
    /**
     * if votes on an option are visible before a person votes
     */
    hide_votes?: boolean;
};

/**
 * Create meeting body
 */
export type CreateMeetingBody = {
    /**
     * Title of the meeting
     */
    title?: string | null;
    /**
     * The region in which this meeting should be created.
     */
    preferred_region?: 'ap-south-1' | 'ap-southeast-1' | 'us-east-1' | 'eu-central-1' | null;
    /**
     * Specifies if the meeting should start getting recorded as soon as someone joins the meeting.
     */
    record_on_start?: boolean | null;
    /**
     * Specifies if the meeting should start getting livestreamed on start.
     */
    live_stream_on_start?: boolean | null;
    recording_config?: RecordingConfigWritable;
    ai_config?: AiConfig;
    /**
     * If a meeting is set to persist_chat, meeting chat would remain for a week within the meeting space.
     */
    persist_chat?: boolean;
    /**
     * Automatically generate summary of meetings using transcripts. Requires Transcriptions to be enabled, and can be retrieved via Webhooks or summary API.
     */
    summarize_on_end?: boolean;
};

/**
 * Create meeting body
 */
export type UpdateMeetingBody = {
    /**
     * Title of the meeting
     */
    title?: string;
    /**
     * The region in which this meeting should be created.
     */
    preferred_region?: 'ap-south-1' | 'ap-southeast-1' | 'us-east-1' | 'eu-central-1';
    /**
     * Specifies if the meeting should start getting recorded as soon as someone joins the meeting.
     */
    record_on_start?: boolean;
    /**
     * Specifies if the meeting should start getting livestreamed on start.
     */
    live_stream_on_start?: boolean;
    /**
     * Whether the meeting is `ACTIVE` or `INACTIVE`. Users will not be able to join an `INACTIVE` meeting.
     */
    status?: 'ACTIVE' | 'INACTIVE';
    /**
     * If a meeting is updated to persist_chat, meeting chat would remain for a week within the meeting space.
     */
    persist_chat?: boolean;
    /**
     * Automatically generate summary of meetings using transcripts. Requires Transcriptions to be enabled, and can be retrieved via Webhooks or summary API.
     */
    summarize_on_end?: boolean;
    ai_config?: AiConfig;
};

export type AddParticipantBody = {
    /**
     * (Optional) Name of the participant.
     */
    name?: string | null;
    /**
     * (Optional) A URL to a picture to be used for the participant.
     */
    picture?: string | null;
    /**
     * Name of the preset to apply to this participant.
     */
    preset_name: string;
    /**
     * A unique participant ID. You must specify a unique ID for the participant, for example, UUID, email address, and so on.
     */
    custom_participant_id: string;
};

export type EditParticipantBody = {
    /**
     * (Optional) Name of the participant.
     */
    name?: string | null;
    /**
     * (Optional) A URL to a picture to be used for the participant.
     */
    picture?: string | null;
    /**
     * (Optional) Name of the preset to apply to this participant.
     */
    preset_name?: string | null;
};

export type StartRecording = {
    /**
     * ID of the meeting to record.
     */
    meeting_id?: string;
    /**
     * Specifies the maximum duration for recording in seconds, ranging from a minimum of 60 seconds to a maximum of 24 hours.
     */
    max_seconds?: number;
    storage_config?: StorageConfigWritable;
    video_config?: VideoConfig;
    audio_config?: AudioConfig;
    rtmp_out_config?: LivestreamingConfig;
    /**
     * Update the recording file name.
     */
    file_name_prefix?: string;
    /**
     * Pass a custom url to record arbitary screen
     */
    url?: string;
    realtimekit_bucket_config?: RealtimekitBucketConfig;
    interactive_config?: InteractiveConfig;
    /**
     * By default, a meeting allows only one recording to run at a time. Enabling the `allow_multiple_recordings` parameter to true allows you to initiate multiple recordings concurrently in the same meeting. This allows you to record separate videos of the same meeting with different configurations, such as portrait mode or landscape mode.
     */
    allow_multiple_recordings?: boolean;
};

export type CreatePresetBody = Preset;

export type UpdatePresetBody = UpdatePreset;

/**
 * For now only "default" layer key is supported.
 */
export type StartTrackRecordingBody = {
    /**
     * ID of the meeting to record.
     */
    meeting_id?: string;
    layers: {
        [key: string]: TrackConfigLayerWritable;
    };
    /**
     * Maximum seconds this recording should be active for (beta)
     */
    max_seconds?: number;
};

export type FetchAllLivestreamsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Exclude the RealtimeKit meetings that are livestreamed.
         */
        exclude_meetings?: boolean;
        /**
         * Number of results per page.
         */
        per_page?: number;
        /**
         * The page number from which you want your page search results to be displayed.
         */
        page_no?: number;
        /**
         * Specifies the status of the operation.
         */
        status?: 'LIVE' | 'IDLE' | 'ERRORED' | 'INVOKED';
        /**
         * Specify the start time range in ISO format to access the live stream.
         */
        start_time?: string;
        /**
         * Specify the end time range in ISO format to access the live stream.
         */
        end_time?: string;
        /**
         * Specifies the sorting order for the results.
         */
        sort_order?: 'ASC' | 'DSC';
    };
    url: '/livestreams';
};

export type FetchAllLivestreamsResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            status?: 'LIVE' | 'IDLE' | 'ERRORED' | 'INVOKED';
            /**
             * The ID of the livestream.
             */
            id?: string;
            /**
             * Name of the livestream.
             */
            name?: string;
            /**
             * The server URL to which the RTMP encoder sends the video and audio data.
             */
            ingest_server?: string;
            /**
             * Unique key for accessing each livestream.
             */
            stream_key?: string;
            /**
             * The web address that viewers can use to watch the livestream.
             */
            playback_url?: string;
            /**
             * ID of the meeting.
             */
            meeting_id?: string;
            /**
             * Timestamp the object was created at. The time is returned in ISO format.
             */
            created_at?: string;
            /**
             * Timestamp the object was updated at. The time is returned in ISO format.
             */
            updated_at?: string;
            /**
             * Specifies if the livestream was disabled.
             */
            disabled?: string;
            paging?: {
                total_count?: number;
                start_offset?: number;
                end_offset?: number;
            };
        };
    };
};

export type FetchAllLivestreamsResponse = FetchAllLivestreamsResponses[keyof FetchAllLivestreamsResponses];

export type PostLivestreamsData = {
    body?: {
        /**
         * Name of the livestream
         */
        name?: string | null;
    };
    path?: never;
    query?: never;
    url: '/livestreams';
};

export type PostLivestreamsResponses = {
    /**
     * Successful response
     */
    201: {
        success?: boolean;
        data?: {
            status?: 'LIVE' | 'IDLE' | 'ERRORED' | 'INVOKED';
            name?: string;
            meeting_id?: string | null;
            /**
             * The server URL to which the RTMP encoder should send the video and audio data.
             */
            ingest_server?: string;
            /**
             * The livestream ID.
             */
            id?: string;
            /**
             * Unique key for accessing each livestream.
             */
            stream_key?: string;
            /**
             * The web address that viewers can use to watch the livestream.
             */
            playback_url?: string;
            /**
             * Specifies if the livestream was disabled.
             */
            disabled?: boolean;
        };
    };
};

export type PostLivestreamsResponse = PostLivestreamsResponses[keyof PostLivestreamsResponses];

export type StopLivestreamingData = {
    body?: never;
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/active-livestream/stop';
};

export type StopLivestreamingResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            message?: string;
        };
    };
};

export type StopLivestreamingResponse = StopLivestreamingResponses[keyof StopLivestreamingResponses];

export type LivestreamSessionDetailsData = {
    body?: never;
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: {
        /**
         * The page number from which you want your page search results to be displayed.
         */
        page_no?: number;
        /**
         * Number of results per page.
         */
        per_page?: number;
    };
    url: '/meetings/{meeting_id}/livestream';
};

export type LivestreamSessionDetailsResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            livestreams?: Array<{
                status?: 'LIVE' | 'INVOKED' | 'ERRORED' | 'IDLE';
                /**
                 * Name of the livestream.
                 */
                name?: string | null;
                /**
                 * The ID of the meeting that was livestreamed.
                 */
                meeting_id?: string;
                /**
                 * The timestamp at which the livestream was created. The time is returned in ISO format.
                 */
                created_at?: string;
                /**
                 * The timestamp at which the livestream was updated. The time is returned in ISO format.
                 */
                updated_at?: string;
                /**
                 * The server URL to which the RTMP encoder sends the video and audio data.
                 */
                ingest_server?: string;
                /**
                 * The livestream ID.
                 */
                id?: string;
                /**
                 * Unique key for accessing each livestream.
                 */
                stream_key?: string;
                /**
                 * The web address that viewers can use to watch the livestream.
                 */
                playback_url?: string;
                /**
                 * Specifies if the livestream was disabled.
                 */
                disabled?: boolean;
            }>;
            sessions?: {
                /**
                 * The ID of the livestream session.
                 */
                id?: string;
                /**
                 * The ID of the livestream.
                 */
                livestream_id?: string;
                err_message?: string;
                /**
                 * The time at which the livestream was invoked.
                 */
                invoked_time?: string;
                /**
                 * The time at which the livestream was started.
                 */
                started_time?: string;
                /**
                 * The time at which the livestream was stopped.
                 */
                stopped_time?: string;
                /**
                 * The timestamp at which the livestream was created. The time is returned in ISO format.
                 */
                created_at?: string;
                /**
                 * The timestamp at which the livestream was updated. The time is returned in ISO format.
                 */
                updated_at?: string;
                /**
                 * The time duration for which the input was given or the meeting was streamed.
                 */
                ingest_seconds?: string;
            };
            paging?: {
                total_count?: number;
                start_offset?: number;
                end_offset?: number;
            };
        };
    };
};

export type LivestreamSessionDetailsResponse = LivestreamSessionDetailsResponses[keyof LivestreamSessionDetailsResponses];

export type StartLivestreamingData = {
    body?: {
        name?: string | null;
        video_config?: {
            /**
             * Height of the livestreaming video in pixels
             */
            height?: number;
            /**
             * Width of the livestreaming video in pixels
             */
            width?: number;
        };
    };
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/livestreams';
};

export type StartLivestreamingResponses = {
    /**
     * Created
     */
    201: {
        success?: boolean;
        data?: {
            status?: 'LIVE' | 'IDLE' | 'ERRORED' | 'INVOKED';
            /**
             * The server URL to which the RTMP encoder sends the video and audio data.
             */
            ingest_server?: string;
            /**
             * The livestream ID.
             */
            id?: string;
            /**
             * Unique key for accessing each livestream.
             */
            stream_key?: string;
            /**
             * The web address that viewers can use to watch the livestream.
             */
            playback_url?: string;
        };
    };
};

export type StartLivestreamingResponse = StartLivestreamingResponses[keyof StartLivestreamingResponses];

export type ResetStreamKeyData = {
    body?: never;
    path: {
        livestream_id: string;
    };
    query?: never;
    url: '/livestreams/{livestream_id}/reset-stream-key';
};

export type ResetStreamKeyResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            /**
             * The ID of the livestream.
             */
            id?: string;
            /**
             * Name of the livestream.
             */
            name?: string;
            /**
             * The server URL to which the RTMP encoder sends the video and audio data.
             */
            ingest_server?: string;
            /**
             * Unique key for accessing each livestream.
             */
            stream_key?: string;
            status?: 'LIVE' | 'IDLE' | 'ERRORED' | 'INVOKED';
            /**
             * The ID of the meeting.
             */
            meeting_id?: string;
            /**
             * The web address that viewers can use to watch the livestream.
             */
            playback_url?: string;
            /**
             * Timestamp the object was created at. The time is returned in ISO format.
             */
            created_at?: string;
            /**
             * Timestamp the object was updated at. The time is returned in ISO format.
             */
            updated_at?: string;
            /**
             * Specifies if the livestream was disabled.
             */
            disabled?: string;
        };
    };
};

export type ResetStreamKeyResponse = ResetStreamKeyResponses[keyof ResetStreamKeyResponses];

export type GetLivestreamAnalyticsCompleteData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Specify the start time range in ISO format to access the livestream analytics.
         */
        start_time?: string;
        /**
         * Specify the end time range in ISO format to access the livestream analytics.
         */
        end_time?: string;
    };
    url: '/analytics/livestreams/overall';
};

export type GetLivestreamAnalyticsCompleteResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            /**
             * Count of total livestreams.
             */
            count?: number;
            /**
             * Total time duration for which the input was given or the meeting was streamed.
             */
            total_ingest_seconds?: number;
            /**
             * Total view time for which the viewers watched the stream.
             */
            total_viewer_seconds?: number;
        };
    };
};

export type GetLivestreamAnalyticsCompleteResponse = GetLivestreamAnalyticsCompleteResponses[keyof GetLivestreamAnalyticsCompleteResponses];

export type GetLivestreamAnalyticsDaywiseData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Specify the start time range in ISO format to access the livestream analytics.
         */
        start_time?: string;
        /**
         * Specify the end time range in ISO format to access the livestream analytics.
         */
        end_time?: string;
    };
    url: '/analytics/livestreams/daywise';
};

export type GetLivestreamAnalyticsDaywiseResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            /**
             * The livestream timestamp, provided in ISO format.
             */
            date?: string;
            /**
             * Count of total livestreams.
             */
            count?: string;
            /**
             * Total time duration for which the input was given or the meeting was streamed.
             */
            total_ingest_seconds?: string;
            /**
             * Total view time for which the viewers watched the stream.
             */
            total_viewer_seconds?: string;
        };
    };
};

export type GetLivestreamAnalyticsDaywiseResponse = GetLivestreamAnalyticsDaywiseResponses[keyof GetLivestreamAnalyticsDaywiseResponses];

export type GetOrgAnalyticsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * start date in YYYY-MM-DD format
         */
        start_date?: string;
        /**
         * end date in YYYY-MM-DD format
         */
        end_date?: string;
    };
    url: '/analytics/daywise';
};

export type GetOrgAnalyticsResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            /**
             * Session statistics of an organization during the range specified
             */
            session_stats?: {
                /**
                 * Total number of sessions during the range specified
                 */
                sessions_count?: number;
                /**
                 * Total session minutes during the range specified
                 */
                sessions_minutes_consumed?: number;
                /**
                 * Day wise session stats
                 */
                day_stats?: Array<{
                    day?: string;
                    /**
                     * Total number of sessions for a specific day
                     */
                    total_sessions?: number;
                    /**
                     * Total session minutes for a specific day
                     */
                    total_session_minutes?: number;
                }>;
            };
            /**
             * Recording statistics of an organization during the range specified
             */
            recording_stats?: {
                /**
                 * Total number of recordings during the range specified
                 */
                recording_count?: number;
                /**
                 * Total recording minutes during the range specified
                 */
                recording_minutes_consumed?: number;
                /**
                 * Day wise recording stats
                 */
                day_stats?: Array<{
                    day?: string;
                    /**
                     * Total number of recordings for a specific day
                     */
                    total_recordings?: number;
                    /**
                     * Total recording minutes for a specific day
                     */
                    total_recording_minutes?: number;
                }>;
            };
        };
    };
};

export type GetOrgAnalyticsResponse = GetOrgAnalyticsResponses[keyof GetOrgAnalyticsResponses];

export type EnableLivestreamData = {
    body?: never;
    path: {
        livestream_id: string;
    };
    query?: never;
    url: '/livestreams/{livestream_id}/enable';
};

export type EnableLivestreamResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: LivestreamBase;
    };
};

export type EnableLivestreamResponse = EnableLivestreamResponses[keyof EnableLivestreamResponses];

export type DisableLivestreamData = {
    body?: never;
    path: {
        livestream_id: string;
    };
    query?: never;
    url: '/livestreams/{livestream_id}/disable';
};

export type DisableLivestreamResponses = {
    /**
     * OK
     */
    200: {
        success?: Success;
        LivestreamBase?: LivestreamBase;
    };
};

export type DisableLivestreamResponse = DisableLivestreamResponses[keyof DisableLivestreamResponses];

export type GetV2LivestreamsessionSessionMeetingIdActiveLivestreamData = {
    body?: never;
    path: {
        session_id: string;
    };
    query?: {
        /**
         * Number of results per page.
         */
        per_page?: number;
        /**
         * The page number from which you want your page search results to be displayed.
         */
        page_no?: number;
    };
    url: '/sessions/{session_id}/livestream-sessions';
};

export type GetV2LivestreamsessionSessionMeetingIdActiveLivestreamResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            err_message?: 'LIVE' | 'IDLE' | 'ERRORED' | 'INVOKED';
            /**
             * Name of the livestream.
             */
            invoked_time?: string | null;
            /**
             * The ID of the livestream.
             */
            livestream_id?: string;
            /**
             * Timestamp the object was created at. The time is returned in ISO format.
             */
            created_at?: string;
            /**
             * Timestamp the object was updated at. The time is returned in ISO format.
             */
            updated_at?: string;
            /**
             * The livestream session ID.
             */
            id?: string;
            /**
             * Specifies if the livestream was disabled.
             */
            stopped_time?: string;
            /**
             * The time duration for which the input was given or the meeting was streamed.
             */
            ingest_seconds?: number;
            /**
             * The total view time for which the viewers watched the stream.
             */
            viewer_seconds?: number;
            paging?: {
                total_count?: number;
                start_offset?: number;
                end_offset?: number;
            };
        };
    };
};

export type GetV2LivestreamsessionSessionMeetingIdActiveLivestreamResponse = GetV2LivestreamsessionSessionMeetingIdActiveLivestreamResponses[keyof GetV2LivestreamsessionSessionMeetingIdActiveLivestreamResponses];

export type GetV2MeetingsMeetingIdActiveLivestreamData = {
    body?: never;
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/active-livestream';
};

export type GetV2MeetingsMeetingIdActiveLivestreamResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            status?: 'LIVE' | 'IDLE' | 'ERRORED' | 'INVOKED';
            /**
             * Name of the livestream.
             */
            name?: string | null;
            meeting_id?: string;
            /**
             * Timestamp the object was created at. The time is returned in ISO format.
             */
            created_at?: string;
            /**
             * Timestamp the object was updated at. The time is returned in ISO format.
             */
            updated_at?: string;
            /**
             * The server URL to which the RTMP encoder sends the video and audio data.
             */
            ingest_server?: string;
            /**
             * The livestream ID.
             */
            id?: string;
            /**
             * Unique key for accessing each livestream.
             */
            stream_key?: string;
            /**
             * The web address that viewers can use to watch the livestream.
             */
            playback_url?: string;
            /**
             * Specifies if the livestream was disabled.
             */
            disabled?: string;
        };
    };
};

export type GetV2MeetingsMeetingIdActiveLivestreamResponse = GetV2MeetingsMeetingIdActiveLivestreamResponses[keyof GetV2MeetingsMeetingIdActiveLivestreamResponses];

export type GetV2LivestreamsLivestreamSessionIdData = {
    body?: never;
    path: {
        'livestream-session-id': string;
    };
    query?: never;
    url: '/livestreams/sessions/{livestream-session-id}';
};

export type GetV2LivestreamsLivestreamSessionIdResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            livestream_id?: string;
            /**
             * Timestamp the object was created at. The time is returned in ISO format.
             */
            created_at?: string;
            /**
             * Timestamp the object was updated at. The time is returned in ISO format.
             */
            updated_at?: string;
            /**
             * The server URL to which the RTMP encoder sends the video and audio data.
             */
            err_message?: string;
            /**
             * The livestream ID.
             */
            id?: string;
            /**
             * Unique key for accessing each livestream.
             */
            started_time?: string;
            /**
             * The web address that viewers can use to watch the livestream.
             */
            stopped_time?: string;
            /**
             * Name of the livestream.
             */
            ingest_seconds?: number;
            /**
             * Specifies if the livestream was disabled.
             */
            viewer_seconds?: number;
        };
    };
};

export type GetV2LivestreamsLivestreamSessionIdResponse = GetV2LivestreamsLivestreamSessionIdResponses[keyof GetV2LivestreamsLivestreamSessionIdResponses];

export type GetV2ActiveLivestreamSessionDetailsData = {
    body?: never;
    path: {
        livestream_id: string;
    };
    query?: never;
    url: '/livestreams/{livestream_id}/active-livestream-session';
};

export type GetV2ActiveLivestreamSessionDetailsResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            livestream?: {
                id?: string;
                /**
                 * Name of the livestream.
                 */
                name?: string;
                /**
                 * The server URL to which the RTMP encoder sends the video and audio data.
                 */
                ingest_server?: string;
                /**
                 * Unique key for accessing each livestream.
                 */
                stream_key?: string;
                status?: 'LIVE' | 'IDLE' | 'ERRORED' | 'INVOKED';
                /**
                 * ID of the meeting.
                 */
                meeting_id?: string;
                /**
                 * The web address that viewers can use to watch the livestream.
                 */
                playback_url?: string;
                /**
                 * Timestamp the object was created at. The time is returned in ISO format.
                 */
                created_at?: string;
                /**
                 * Timestamp the object was updated at. The time is returned in ISO format.
                 */
                updated_at?: string;
                /**
                 * Specifies if the livestream was disabled.
                 */
                disabled?: string;
            };
            session?: {
                id?: string;
                livestream_id?: string;
                err_message?: string;
                /**
                 * Timestamp the object was invoked. The time is returned in ISO format.
                 */
                invoked_time?: string;
                /**
                 * Timestamp the object was started. The time is returned in ISO format.
                 */
                started_time?: string;
                /**
                 * Timestamp the object was stopped. The time is returned in ISO format.
                 */
                stopped_time?: string;
                /**
                 * Timestamp the object was created at. The time is returned in ISO format.
                 */
                created_at?: string;
                /**
                 * Timestamp the object was updated at. The time is returned in ISO format.
                 */
                updated_at?: string;
                /**
                 * The time duration for which the input was given or the meeting was streamed.
                 */
                ingest_seconds?: string;
                /**
                 * The total view time for which the viewers watched the stream.
                 */
                viewer_seconds?: string;
            };
        };
    };
};

export type GetV2ActiveLivestreamSessionDetailsResponse = GetV2ActiveLivestreamSessionDetailsResponses[keyof GetV2ActiveLivestreamSessionDetailsResponses];

export type GetV2LivestreamSessionLivestreamIdData = {
    body?: never;
    path: {
        livestream_id: string;
    };
    query?: {
        /**
         * The page number from which you want your page search results to be displayed.
         */
        page_no?: number;
        /**
         * Number of results per page.
         */
        per_page?: number;
    };
    url: '/livestreams/{livestream_id}';
};

export type GetV2LivestreamSessionLivestreamIdResponses = {
    /**
     * OK
     */
    200: {
        success?: boolean;
        data?: {
            livestream?: {
                /**
                 * ID of the livestream.
                 */
                id?: string;
                /**
                 * Name of the livestream.
                 */
                name?: string;
                /**
                 * The server URL to which the RTMP encoder sends the video and audio data.
                 */
                ingest_server?: string;
                /**
                 * Unique key for accessing each livestream.
                 */
                stream_key?: string;
                status?: 'LIVE' | 'IDLE' | 'ERRORED' | 'INVOKED';
                /**
                 * The ID of the meeting.
                 */
                meeting_id?: string;
                /**
                 * The web address that viewers can use to watch the livestream.
                 */
                playback_url?: string;
                /**
                 * Timestamp the object was created at. The time is returned in ISO format.
                 */
                created_at?: string;
                /**
                 * Timestamp the object was updated at. The time is returned in ISO format.
                 */
                updated_at?: string;
                /**
                 * Specifies if the livestream was disabled.
                 */
                disabled?: string;
            };
            session?: {
                /**
                 * ID of the session.
                 */
                id?: string;
                livestream_id?: string;
                err_message?: string;
                /**
                 * Timestamp the object was invoked. The time is returned in ISO format.
                 */
                invoked_time?: string;
                /**
                 * Timestamp the object was started. The time is returned in ISO format.
                 */
                started_time?: string;
                /**
                 * Timestamp the object was stopped. The time is returned in ISO format.
                 */
                stopped_time?: string;
                /**
                 * Timestamp the object was created at. The time is returned in ISO format.
                 */
                created_at?: string;
                /**
                 * Timestamp the object was updated at. The time is returned in ISO format.
                 */
                updated_at?: string;
                /**
                 * The time duration for which the input was given or the meeting was streamed.
                 */
                ingest_seconds?: number;
                /**
                 * The total view time for which the viewers watched the stream.
                 */
                viewer_seconds?: number;
            };
            paging?: {
                total_count?: number;
                start_offset?: number;
                end_offset?: number;
            };
        };
    };
};

export type GetV2LivestreamSessionLivestreamIdResponse = GetV2LivestreamSessionLivestreamIdResponses[keyof GetV2LivestreamSessionLivestreamIdResponses];

export type GetActiveSessionData = {
    body?: never;
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/active-session';
};

export type GetActiveSessionErrors = {
    /**
     * Active Session is not found for the given meetingId
     */
    404: GenericErrorResponse;
};

export type GetActiveSessionError = GetActiveSessionErrors[keyof GetActiveSessionErrors];

export type GetActiveSessionResponses = {
    /**
     * Active Session Success response
     */
    200: {
        success?: boolean;
        data?: ActiveSessionReadable;
    };
};

export type GetActiveSessionResponse = GetActiveSessionResponses[keyof GetActiveSessionResponses];

export type KickPartcipantsData = {
    /**
     * Request body for kicking participants from an active session. Only one of `participant_id` or `custom_participant_id` is required.
     */
    body?: KickParticipantsBody;
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/active-session/kick';
};

export type KickPartcipantsErrors = {
    /**
     * No participant found for the given `participant_id` or `custom_participant_id`
     */
    404: GenericErrorResponse;
};

export type KickPartcipantsError = KickPartcipantsErrors[keyof KickPartcipantsErrors];

export type KickPartcipantsResponses = {
    /**
     * Kick participants success response
     */
    200: {
        success?: boolean;
        data?: {
            action?: string;
            participants?: Array<SessionParticipant>;
        };
    };
};

export type KickPartcipantsResponse = KickPartcipantsResponses[keyof KickPartcipantsResponses];

export type KickAllParticipantsData = {
    body?: never;
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/active-session/kick-all';
};

export type KickAllParticipantsResponses = {
    /**
     * Kick all participants from a meeting
     */
    200: {
        success?: boolean;
        data?: {
            action?: string;
            kicked_participants_count?: number;
        };
    };
};

export type KickAllParticipantsResponse = KickAllParticipantsResponses[keyof KickAllParticipantsResponses];

export type MuteParticipantsData = {
    /**
     * Request body for kicking participants from an active session. Only one of `participant_id` or `custom_participant_id` is required.
     */
    body?: KickParticipantsBody;
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/active-session/mute';
};

export type MuteParticipantsResponses = {
    /**
     * Mute one or more participants of a meeting
     */
    200: {
        success?: boolean;
        data?: {
            action?: string;
            participants?: Array<SessionParticipant>;
        };
    };
};

export type MuteParticipantsResponse = MuteParticipantsResponses[keyof MuteParticipantsResponses];

export type MuteAllParticipantsData = {
    /**
     * Request body for muting all participants in an active session.
     */
    body?: MuteAllParticipantsBody;
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/active-session/mute-all';
};

export type MuteAllParticipantsResponses = {
    /**
     * Mute all participants of a meeting
     */
    200: {
        success?: boolean;
        data?: {
            action?: string;
            muted_participants_count?: number;
        };
    };
};

export type MuteAllParticipantsResponse = MuteAllParticipantsResponses[keyof MuteAllParticipantsResponses];

export type CreatePollData = {
    /**
     * Request body for creating a new poll
     */
    body?: CreatePollBody;
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/active-session/poll';
};

export type CreatePollErrors = {
    /**
     * Bad Request
     */
    400: unknown;
};

export type CreatePollResponses = {
    /**
     * response for creating a poll
     */
    201: {
        success?: boolean;
        data?: {
            action?: string;
            poll?: PollReadable;
        };
    };
};

export type CreatePollResponse = CreatePollResponses[keyof CreatePollResponses];

export type GetSessionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The page number from which you want your page search results to be displayed.
         */
        page_no?: number;
        /**
         * Number of results per page
         */
        per_page?: number;
        sort_by?: 'minutesConsumed' | 'createdAt';
        sort_order?: 'ASC' | 'DESC';
        /**
         * The start time range for which you want to retrieve the meetings. The time must be specified in ISO format.
         */
        start_time?: string;
        /**
         * The end time range for which you want to retrieve the meetings. The time must be specified in ISO format.
         */
        end_time?: string;
        participants?: string;
        status?: 'LIVE' | 'ENDED';
        /**
         * Search string that matches sessions based on meeting title, meeting ID, and session ID
         */
        search?: string;
        /**
         * ID of the meeting that sessions should be associated with
         */
        associated_id?: string;
    };
    url: '/sessions';
};

export type GetSessionsResponses = {
    /**
     * Get all sessions success response
     */
    200: {
        success?: boolean;
        data?: {
            sessions?: Array<ActiveSessionReadable>;
        };
    };
};

export type GetSessionsResponse = GetSessionsResponses[keyof GetSessionsResponses];

export type GetSessionDetailsData = {
    body?: never;
    path: {
        /**
         * ID of the session
         */
        session_id: string;
    };
    query?: {
        /**
         * List all breakout rooms
         */
        include_breakout_rooms?: boolean;
    };
    url: '/sessions/{session_id}';
};

export type GetSessionDetailsResponses = {
    /**
     * Get details about a particular session
     */
    200: {
        success?: boolean;
        data?: {
            session?: ActiveSessionReadable;
        };
    };
};

export type GetSessionDetailsResponse = GetSessionDetailsResponses[keyof GetSessionDetailsResponses];

export type GetSessionParticipantsData = {
    body?: never;
    path: {
        /**
         * ID of the session
         */
        session_id: string;
    };
    query?: {
        /**
         * The search query string. You can search using the meeting ID or title.
         */
        search?: string;
        /**
         * The page number from which you want your page search results to be displayed.
         */
        page_no?: number;
        /**
         * Number of results per page
         */
        per_page?: number;
        sort_order?: 'ASC' | 'DESC';
        sort_by?: 'joinedAt' | 'duration';
        /**
         * if true, response includes all the peer events of participants.
         */
        include_peer_events?: boolean;
        /**
         * In breakout room sessions, the view parameter can be set to `raw` for session specific duration for participants or `consolidated` to accumulate breakout room durations.
         */
        view?: 'raw' | 'consolidated';
    };
    url: '/sessions/{session_id}/participants';
};

export type GetSessionParticipantsResponses = {
    /**
     * Get participants list of a particular session
     */
    200: {
        success?: boolean;
        data?: {
            participants?: Array<ParticipantsList>;
        };
    };
};

export type GetSessionParticipantsResponse = GetSessionParticipantsResponses[keyof GetSessionParticipantsResponses];

export type GetParticipantDetailsData = {
    body?: never;
    path: {
        /**
         * ID of the participant
         */
        participant_id: string;
        /**
         * ID of the session
         */
        session_id: string;
    };
    query?: {
        /**
         * Comma separated list of filters to apply. Note that there must be no spaces between the filters.
         */
        filters?: 'device_info' | 'ip_information' | 'precall_network_information' | 'events' | 'quality_stats';
        /**
         * if true, response includes all the peer events of participant.
         */
        include_peer_events?: boolean;
    };
    url: '/sessions/{session_id}/participants/{participant_id}';
};

export type GetParticipantDetailsResponses = {
    /**
     * Returns details of a participant along with callstats data.
     */
    200: {
        success?: boolean;
        data?: {
            participant?: ParticipantsList & ParticipantPeerStats & ParticipantQualityStats;
        };
    };
};

export type GetParticipantDetailsResponse = GetParticipantDetailsResponses[keyof GetParticipantDetailsResponses];

export type GetSessionChatData = {
    body?: never;
    path: {
        /**
         * ID of the session
         */
        session_id: string;
    };
    query?: never;
    url: '/sessions/{session_id}/chat';
};

export type GetSessionChatResponses = {
    /**
     * Returns all chat messages of a session.
     */
    200: {
        success?: boolean;
        data?: ChatMessage;
    };
};

export type GetSessionChatResponse = GetSessionChatResponses[keyof GetSessionChatResponses];

export type GetSessionTranscriptData = {
    body?: never;
    path: {
        /**
         * ID of the session
         */
        session_id: string;
    };
    query?: never;
    url: '/sessions/{session_id}/transcript';
};

export type GetSessionTranscriptResponses = {
    /**
     * Returns the complete transcript of a session.
     */
    200: {
        success?: boolean;
        data?: Transcript;
    };
};

export type GetSessionTranscriptResponse = GetSessionTranscriptResponses[keyof GetSessionTranscriptResponses];

export type GetSessionSummaryData = {
    body?: never;
    path: {
        session_id: string;
    };
    query?: never;
    url: '/sessions/{session_id}/summary';
};

export type GetSessionSummaryResponses = {
    /**
     * Returns a complete summary of transcripts of a session.
     */
    200: {
        success?: boolean;
        data?: TranscriptSummary;
    };
};

export type GetSessionSummaryResponse = GetSessionSummaryResponses[keyof GetSessionSummaryResponses];

export type PostSessionsSessionIdSummaryData = {
    body?: never;
    path: {
        session_id: string;
    };
    query?: never;
    url: '/sessions/{session_id}/summary';
};

export type PostSessionsSessionIdSummaryResponses = {
    /**
     * Success
     */
    '2XX': {
        success?: boolean;
        data?: {
            success?: boolean;
            message?: string;
        };
    };
};

export type PostSessionsSessionIdSummaryResponse = PostSessionsSessionIdSummaryResponses[keyof PostSessionsSessionIdSummaryResponses];

export type GetAllWebhooksData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/webhooks';
};

export type GetAllWebhooksErrors = {
    /**
     * Invalid credentials
     */
    401: unknown;
};

export type GetAllWebhooksResponses = {
    /**
     * Operation successful
     */
    200: WebhooksListSuccessResponseReadable;
};

export type GetAllWebhooksResponse = GetAllWebhooksResponses[keyof GetAllWebhooksResponses];

export type AddWebhookData = {
    body: WebhookRequest;
    path?: never;
    query?: never;
    url: '/webhooks';
};

export type AddWebhookErrors = {
    /**
     * Error - malformed request
     */
    400: ErrorResponse;
    /**
     * Invalid credentials
     */
    401: unknown;
};

export type AddWebhookError = AddWebhookErrors[keyof AddWebhookErrors];

export type AddWebhookResponses = {
    /**
     * Webhook registered successfully
     */
    201: WebhookSuccessResponseReadable;
};

export type AddWebhookResponse = AddWebhookResponses[keyof AddWebhookResponses];

export type DeleteWebhookData = {
    body?: never;
    path: {
        /**
         * ID of the webhook
         */
        webhook_id: string;
    };
    query?: never;
    url: '/webhooks/{webhook_id}';
};

export type DeleteWebhookErrors = {
    /**
     * Error - malformed request
     */
    400: ErrorResponse;
    /**
     * Invalid credentials
     */
    401: unknown;
};

export type DeleteWebhookError = DeleteWebhookErrors[keyof DeleteWebhookErrors];

export type DeleteWebhookResponses = {
    /**
     * Operation successful
     */
    200: WebhookSuccessResponseReadable;
};

export type DeleteWebhookResponse = DeleteWebhookResponses[keyof DeleteWebhookResponses];

export type GetWebhookData = {
    body?: never;
    path: {
        /**
         * ID of the webhook
         */
        webhook_id: string;
    };
    query?: never;
    url: '/webhooks/{webhook_id}';
};

export type GetWebhookErrors = {
    /**
     * Error - malformed request
     */
    400: ErrorResponse;
    /**
     * Invalid credentials
     */
    401: unknown;
};

export type GetWebhookError = GetWebhookErrors[keyof GetWebhookErrors];

export type GetWebhookResponses = {
    /**
     * Operation successful
     */
    200: WebhookSuccessResponseReadable;
};

export type GetWebhookResponse = GetWebhookResponses[keyof GetWebhookResponses];

export type EditWebhookData = {
    body: PatchWebhookRequest;
    path: {
        /**
         * ID of the webhook
         */
        webhook_id: string;
    };
    query?: never;
    url: '/webhooks/{webhook_id}';
};

export type EditWebhookErrors = {
    /**
     * Error - malformed request
     */
    400: ErrorResponse;
    /**
     * Invalid credentials
     */
    401: unknown;
};

export type EditWebhookError = EditWebhookErrors[keyof EditWebhookErrors];

export type EditWebhookResponses = {
    /**
     * Operation successful
     */
    200: WebhookSuccessResponseReadable;
};

export type EditWebhookResponse = EditWebhookResponses[keyof EditWebhookResponses];

export type ReplaceWebhookData = {
    body: WebhookRequest;
    path: {
        /**
         * ID of the webhook
         */
        webhook_id: string;
    };
    query?: never;
    url: '/webhooks/{webhook_id}';
};

export type ReplaceWebhookErrors = {
    /**
     * Error - malformed request
     */
    400: ErrorResponse;
    /**
     * Invalid credentials
     */
    401: unknown;
};

export type ReplaceWebhookError = ReplaceWebhookErrors[keyof ReplaceWebhookErrors];

export type ReplaceWebhookResponses = {
    /**
     * Operation successful
     */
    200: WebhookSuccessResponseReadable;
};

export type ReplaceWebhookResponse = ReplaceWebhookResponses[keyof ReplaceWebhookResponses];

export type GetAllOrgsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of values to return in a single page. Default value is 25.
         */
        per_page?: number;
        /**
         * The page number to return. Default value is 1.
         */
        page_no?: number;
    };
    url: '/orgs';
};

export type GetAllOrgsErrors = {
    /**
     * Malformed request
     */
    400: ErrorResponse;
    /**
     * Unauthorized user
     */
    401: ErrorResponse;
};

export type GetAllOrgsError = GetAllOrgsErrors[keyof GetAllOrgsErrors];

export type GetAllOrgsResponses = {
    /**
     * Operation successful
     */
    200: OrganizationListSuccessResponse;
};

export type GetAllOrgsResponse = GetAllOrgsResponses[keyof GetAllOrgsResponses];

export type CreateOrgData = {
    body: OrganizationRequest;
    path?: never;
    query?: never;
    url: '/orgs';
};

export type CreateOrgErrors = {
    /**
     * Malformed request
     */
    400: ErrorResponse;
    /**
     * Unauthorized user
     */
    401: ErrorResponse;
    /**
     * Organization with the provided name already exists
     */
    409: ErrorResponse;
};

export type CreateOrgError = CreateOrgErrors[keyof CreateOrgErrors];

export type CreateOrgResponses = {
    /**
     * Operation successful
     */
    201: OrganizationSuccessResponse;
};

export type CreateOrgResponse = CreateOrgResponses[keyof CreateOrgResponses];

export type GetOrgData = {
    body?: never;
    path: {
        /**
         * ID of the organization
         */
        org_id: string;
    };
    query?: never;
    url: '/orgs/{org_id}';
};

export type GetOrgErrors = {
    /**
     * Malformed request
     */
    400: ErrorResponse;
    /**
     * User is not authorized to perform this operation.
     */
    401: ErrorResponse;
};

export type GetOrgError = GetOrgErrors[keyof GetOrgErrors];

export type GetOrgResponses = {
    /**
     * Operation successful
     */
    200: OrganizationSuccessResponse;
};

export type GetOrgResponse = GetOrgResponses[keyof GetOrgResponses];

export type EditOrgData = {
    body: PatchOrganizationRequest;
    path: {
        /**
         * ID of the organization
         */
        org_id: string;
    };
    query?: never;
    url: '/orgs/{org_id}';
};

export type EditOrgErrors = {
    /**
     * Malformed request
     */
    400: ErrorResponse;
    /**
     * Unauthorized user
     */
    401: ErrorResponse;
};

export type EditOrgError = EditOrgErrors[keyof EditOrgErrors];

export type EditOrgResponses = {
    /**
     * Operation successful
     */
    200: OrganizationSuccessResponse;
};

export type EditOrgResponse = EditOrgResponses[keyof EditOrgResponses];

export type GetAllMeetingsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The page number from which you want your page search results to be displayed.
         */
        page_no?: number;
        /**
         * Number of results per page
         */
        per_page?: number;
        /**
         * The start time range for which you want to retrieve the meetings. The time must be specified in ISO format.
         */
        start_time?: string;
        /**
         * The end time range for which you want to retrieve the meetings. The time must be specified in ISO format.
         */
        end_time?: string;
        /**
         * The search query string. You can search using the meeting ID or title.
         */
        search?: string;
    };
    url: '/meetings';
};

export type GetAllMeetingsResponses = {
    /**
     * Success response
     */
    200: PagingResponse & {
        data?: Array<MeetingReadable>;
    };
};

export type GetAllMeetingsResponse = GetAllMeetingsResponses[keyof GetAllMeetingsResponses];

export type CreateMeetingData = {
    /**
     * Create meeting body
     */
    body?: CreateMeetingBody;
    path?: never;
    query?: never;
    url: '/meetings';
};

export type CreateMeetingResponses = {
    /**
     * Success Response
     */
    201: GenericSuccessResponse & ({
        data?: MeetingReadable;
    } & {
        data?: {
            recording_config?: RecordingConfigReadable;
        };
    } & {
        data?: {
            ai_config?: AiConfig;
        };
    }) & {
        [key: string]: unknown;
    };
};

export type CreateMeetingResponse = CreateMeetingResponses[keyof CreateMeetingResponses];

export type GetMeetingData = {
    body?: never;
    path: {
        /**
         * ID of the meeting. Fetch the meeting ID using the create a meeting API.
         */
        meeting_id: string;
    };
    query?: {
        name?: string;
    };
    url: '/meetings/{meeting_id}';
};

export type GetMeetingErrors = {
    /**
     * Failure response
     */
    500: GenericErrorResponse;
};

export type GetMeetingError = GetMeetingErrors[keyof GetMeetingErrors];

export type GetMeetingResponses = {
    /**
     * Success Response
     */
    200: GenericSuccessResponse & ({
        data?: MeetingReadable;
    } & {
        data?: {
            recording_config?: RecordingConfigReadable;
        };
    } & {
        data?: {
            ai_config?: AiConfig;
        };
    }) & {
        [key: string]: unknown;
    };
};

export type GetMeetingResponse = GetMeetingResponses[keyof GetMeetingResponses];

export type UpdateMeetingData = {
    /**
     * Create meeting body
     */
    body?: UpdateMeetingBody;
    path: {
        /**
         * ID of the meeting. Fetch the meeting ID using the create a meeting API.
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}';
};

export type UpdateMeetingErrors = {
    /**
     * Failure response
     */
    500: GenericErrorResponse;
};

export type UpdateMeetingError = UpdateMeetingErrors[keyof UpdateMeetingErrors];

export type UpdateMeetingResponses = {
    /**
     * Success Response
     */
    200: GenericSuccessResponse & ({
        data?: MeetingReadable;
    } & {
        data?: {
            recording_config?: RecordingConfigReadable;
        };
    } & {
        data?: {
            ai_config?: AiConfig;
        };
    }) & {
        [key: string]: unknown;
    };
};

export type UpdateMeetingResponse = UpdateMeetingResponses[keyof UpdateMeetingResponses];

export type ReplaceMeetingData = {
    /**
     * Create meeting body
     */
    body?: CreateMeetingBody;
    path: {
        /**
         * ID of the meeting. Fetch the meeting ID using the create a meeting API.
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}';
};

export type ReplaceMeetingResponses = {
    /**
     * Success Response
     */
    200: GenericSuccessResponse & ({
        data?: MeetingReadable;
    } & {
        data?: {
            recording_config?: RecordingConfigReadable;
        };
    } & {
        data?: {
            ai_config?: AiConfig;
        };
    }) & {
        [key: string]: unknown;
    };
};

export type ReplaceMeetingResponse = ReplaceMeetingResponses[keyof ReplaceMeetingResponses];

export type GetMeetingParticipantsData = {
    body?: never;
    path: {
        /**
         * ID of the meeting. Fetch the meeting ID using the create a meeting API.
         */
        meeting_id: string;
    };
    query?: {
        /**
         * The page number from which you want your page search results to be displayed.
         */
        page_no?: number;
        /**
         * Number of results per page
         */
        per_page?: number;
    };
    url: '/meetings/{meeting_id}/participants';
};

export type GetMeetingParticipantsErrors = {
    /**
     * Failure response
     */
    500: GenericErrorResponse;
};

export type GetMeetingParticipantsError = GetMeetingParticipantsErrors[keyof GetMeetingParticipantsErrors];

export type GetMeetingParticipantsResponses = {
    /**
     * Success response
     */
    200: PagingResponse & {
        data?: Array<Participant>;
    };
};

export type GetMeetingParticipantsResponse = GetMeetingParticipantsResponses[keyof GetMeetingParticipantsResponses];

export type AddParticipantData = {
    body?: AddParticipantBody;
    path: {
        /**
         * ID of the meeting. Fetch the meeting ID using the create a meeting API.
         */
        meeting_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/participants';
};

export type AddParticipantErrors = {
    /**
     * Failure response
     */
    500: GenericErrorResponse;
};

export type AddParticipantError = AddParticipantErrors[keyof AddParticipantErrors];

export type AddParticipantResponses = {
    /**
     * Success response
     */
    201: GenericSuccessResponse & {
        data?: Participant & {
            /**
             * The participant's auth token that can be used for joining a meeting from the client side.
             */
            token: string;
        };
    };
};

export type AddParticipantResponse = AddParticipantResponses[keyof AddParticipantResponses];

export type DeleteMeetingParticipantData = {
    body?: never;
    path: {
        /**
         * ID of the meeting. You can fetch the meeting ID using the create a meeting API.
         */
        meeting_id: string;
        /**
         * ID of the participant. You can fetch the participant ID using the add a participant API.
         */
        participant_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/participants/{participant_id}';
};

export type DeleteMeetingParticipantErrors = {
    /**
     * Failure response
     */
    500: GenericErrorResponse;
};

export type DeleteMeetingParticipantError = DeleteMeetingParticipantErrors[keyof DeleteMeetingParticipantErrors];

export type DeleteMeetingParticipantResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data?: {
            /**
             * A unique participant ID generated by the client.
             */
            custom_participant_id: string;
            /**
             * ID of the preset applied to this participant.
             */
            preset_id: string;
            /**
             * Timestamp this object was created at. The time is returned in ISO format.
             */
            created_at: string;
            /**
             * Timestamp this object was updated at. The time is returned in ISO format.
             */
            updated_at: string;
        };
    };
};

export type DeleteMeetingParticipantResponse = DeleteMeetingParticipantResponses[keyof DeleteMeetingParticipantResponses];

export type GetMeetingParticipantData = {
    body?: never;
    path: {
        /**
         * ID of the meeting. You can fetch the meeting ID using the create a meeting API.
         */
        meeting_id: string;
        /**
         * ID of the participant. You can fetch the participant ID using the add a participant API.
         */
        participant_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/participants/{participant_id}';
};

export type GetMeetingParticipantErrors = {
    /**
     * Failure response
     */
    500: GenericErrorResponse;
};

export type GetMeetingParticipantError = GetMeetingParticipantErrors[keyof GetMeetingParticipantErrors];

export type GetMeetingParticipantResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data: Participant;
    };
};

export type GetMeetingParticipantResponse = GetMeetingParticipantResponses[keyof GetMeetingParticipantResponses];

export type EditParticipantData = {
    body?: EditParticipantBody;
    path: {
        /**
         * ID of the meeting. You can fetch the meeting ID using the create a meeting API.
         */
        meeting_id: string;
        /**
         * ID of the participant. You can fetch the participant ID using the add a participant API.
         */
        participant_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/participants/{participant_id}';
};

export type EditParticipantErrors = {
    /**
     * Failure response
     */
    500: GenericErrorResponse;
};

export type EditParticipantError = EditParticipantErrors[keyof EditParticipantErrors];

export type EditParticipantResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data?: Participant & {
            /**
             * The participant's auth token that can be used for joining a meeting from the client side.
             */
            token: string;
        };
    };
};

export type EditParticipantResponse = EditParticipantResponses[keyof EditParticipantResponses];

export type RegenerateTokenData = {
    body?: never;
    path: {
        /**
         * ID of the meeting. You can fetch the meeting ID using the create a meeting API.
         */
        meeting_id: string;
        /**
         * ID of the participant. You can fetch the participant ID using the add a  participant API.
         */
        participant_id: string;
    };
    query?: never;
    url: '/meetings/{meeting_id}/participants/{participant_id}/token';
};

export type RegenerateTokenErrors = {
    /**
     * Failure response
     */
    500: GenericErrorResponse;
};

export type RegenerateTokenError = RegenerateTokenErrors[keyof RegenerateTokenErrors];

export type RegenerateTokenResponses = {
    /**
     * Example response
     */
    200: GenericSuccessResponse & {
        data: {
            /**
             * Regenerated participant's authentication token.
             */
            token: string;
        };
    };
};

export type RegenerateTokenResponse = RegenerateTokenResponses[keyof RegenerateTokenResponses];

export type GetAllRecordingsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * ID of a meeting. Optional. Will limit results to only this meeting if passed.
         */
        meeting_id?: string;
        /**
         * The page number from which you want your page search results to be displayed.
         */
        page_no?: number;
        /**
         * Number of results per page
         */
        per_page?: number;
        /**
         * If passed, only shows expired/non-expired recordings on RealtimeKit's bucket
         */
        expired?: boolean;
        /**
         * The search query string. You can search using the meeting ID or title.
         */
        search?: string;
        sort_by?: 'invokedTime';
        sort_order?: 'ASC' | 'DESC';
        /**
         * The start time range for which you want to retrieve the meetings. The time must be specified in ISO format.
         */
        start_time?: string;
        /**
         * The end time range for which you want to retrieve the meetings. The time must be specified in ISO format.
         */
        end_time?: string;
        /**
         * Filter by one or more recording status
         */
        status?: Array<'INVOKED' | 'RECORDING' | 'UPLOADING' | 'UPLOADED'>;
    };
    url: '/recordings';
};

export type GetAllRecordingsResponses = {
    /**
     * Success response
     */
    200: PagingResponse & {
        data?: Array<RecordingReadable & {
            storage_config?: StorageConfigReadable;
        } & {
            meeting?: MeetingReadable;
        }>;
    };
    /**
     * Created
     */
    201: unknown;
};

export type GetAllRecordingsResponse = GetAllRecordingsResponses[keyof GetAllRecordingsResponses];

export type StartRecordingData = {
    body?: StartRecording;
    path?: never;
    query?: never;
    url: '/recordings';
};

export type StartRecordingResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data?: RecordingReadable & {
            storage_config?: StorageConfigReadable;
            start_reason?: StartReason;
            stop_reason?: StopReason;
        };
    };
};

export type StartRecordingResponse = StartRecordingResponses[keyof StartRecordingResponses];

export type GetActiveRecordingData = {
    body?: never;
    path: {
        /**
         * ID of the meeting
         */
        meeting_id: string;
    };
    query?: never;
    url: '/recordings/active-recording/{meeting_id}';
};

export type GetActiveRecordingErrors = {
    /**
     * Failure response
     */
    404: GenericErrorResponse;
};

export type GetActiveRecordingError = GetActiveRecordingErrors[keyof GetActiveRecordingErrors];

export type GetActiveRecordingResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data: RecordingReadable;
    };
};

export type GetActiveRecordingResponse = GetActiveRecordingResponses[keyof GetActiveRecordingResponses];

export type GetOneRecordingData = {
    body?: never;
    path: {
        /**
         * ID of the recording
         */
        recording_id: string;
    };
    query?: never;
    url: '/recordings/{recording_id}';
};

export type GetOneRecordingResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data?: RecordingReadable & {
            storage_config?: StorageConfigReadable;
            start_reason?: StartReason;
            stop_reason?: StopReason;
        };
    };
};

export type GetOneRecordingResponse = GetOneRecordingResponses[keyof GetOneRecordingResponses];

export type PauseResumeStopRecordingData = {
    body?: {
        action: 'stop' | 'pause' | 'resume';
    };
    path: {
        /**
         * ID of the recording
         */
        recording_id: string;
    };
    query?: never;
    url: '/recordings/{recording_id}';
};

export type PauseResumeStopRecordingResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data?: RecordingReadable & {
            storage_config?: StorageConfigReadable;
            start_reason?: StartReason;
            stop_reason?: StopReason;
        };
    };
};

export type PauseResumeStopRecordingResponse = PauseResumeStopRecordingResponses[keyof PauseResumeStopRecordingResponses];

export type GetPresetsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of results per page
         */
        per_page?: number;
        /**
         * The page number from which you want your page search results to be displayed.
         */
        page_no?: number;
    };
    url: '/presets';
};

export type GetPresetsResponses = {
    /**
     * Example response
     */
    200: PagingResponse & {
        data?: Array<PresetListItem>;
    };
};

export type GetPresetsResponse = GetPresetsResponses[keyof GetPresetsResponses];

export type PostPresetsData = {
    body?: CreatePresetBody;
    path?: never;
    query?: never;
    url: '/presets';
};

export type PostPresetsResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data: {
            /**
             * ID of the preset
             */
            id: string;
        } & Preset;
    };
};

export type PostPresetsResponse = PostPresetsResponses[keyof PostPresetsResponses];

export type DeletePresetsPresetIdData = {
    body?: never;
    path: {
        /**
         * ID of the preset to fetch
         */
        preset_id: string;
    };
    query?: never;
    url: '/presets/{preset_id}';
};

export type DeletePresetsPresetIdResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data: {
            /**
             * ID of the preset
             */
            id: string;
        } & Preset;
    };
};

export type DeletePresetsPresetIdResponse = DeletePresetsPresetIdResponses[keyof DeletePresetsPresetIdResponses];

export type GetPresetsPresetIdData = {
    body?: never;
    path: {
        /**
         * ID of the preset to fetch
         */
        preset_id: string;
    };
    query?: never;
    url: '/presets/{preset_id}';
};

export type GetPresetsPresetIdResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data: {
            /**
             * ID of the preset
             */
            id: string;
        } & Preset;
    };
};

export type GetPresetsPresetIdResponse = GetPresetsPresetIdResponses[keyof GetPresetsPresetIdResponses];

export type PatchPresetsPresetIdData = {
    body?: UpdatePresetBody;
    path: {
        /**
         * ID of the preset to fetch
         */
        preset_id: string;
    };
    query?: never;
    url: '/presets/{preset_id}';
};

export type PatchPresetsPresetIdResponses = {
    /**
     * Success response
     */
    200: GenericSuccessResponse & {
        data: {
            /**
             * ID of the preset
             */
            id: string;
        } & Preset;
    };
};

export type PatchPresetsPresetIdResponse = PatchPresetsPresetIdResponses[keyof PatchPresetsPresetIdResponses];

export type GetParticipantDataFromPeerIdData = {
    body?: never;
    path: {
        /**
         * ID of the peer
         */
        peer_id: string;
    };
    query?: {
        /**
         * Comma separated list of filters to apply. Note that there must be no spaces between the filters.
         */
        filters?: 'device_info' | 'ip_information' | 'precall_network_information' | 'events' | 'quality_stats';
    };
    url: '/sessions/peer-report/{peer_id}';
};

export type GetParticipantDataFromPeerIdResponses = {
    /**
     * Returns details of a participant (using peer id) along with callstats data.
     */
    200: {
        success?: boolean;
        data?: {
            participant?: {
                id?: string;
                user_id?: string;
                custom_participant_id?: string;
                display_name?: string;
                role?: string;
                joined_at?: string;
                left_at?: string;
                duration?: number;
                created_at?: string;
                updated_at?: string;
                peer_stats?: {
                    events?: Array<{
                        type?: string;
                        timestamp?: string;
                        metadata?: {
                            connection_info?: {
                                ip_details?: {
                                    city?: string;
                                    country?: string;
                                    region?: string;
                                    loc?: string;
                                    timezone?: string;
                                    ip?: string;
                                    postal?: string;
                                    asn?: {
                                        asn?: string;
                                    };
                                };
                                effective_network_type?: string;
                                location?: {
                                    coords?: {
                                        latitude?: number;
                                        longitude?: number;
                                    };
                                };
                                turn_connectivity?: boolean;
                                connectivity?: {
                                    host?: boolean;
                                    relay?: boolean;
                                    reflexive?: boolean;
                                };
                                throughput?: number;
                                fractional_loss?: number;
                                r_t_t?: number;
                                jitter?: number;
                                backend_r_t_t?: number;
                            };
                        };
                    }>;
                    device_info?: {
                        browser?: string;
                        browser_version?: string;
                        cpus?: number;
                        engine?: string;
                        is_mobile?: boolean;
                        os?: string;
                        os_version?: string;
                        sdk_name?: string;
                        sdk_version?: string;
                        user_agent?: string;
                        webgl_support?: string;
                    };
                    ip_information?: {
                        city?: string;
                        country?: string;
                        timezone?: string;
                        region?: string;
                        asn?: {
                            asn?: string;
                        };
                        ipv4?: string;
                        ip_location?: string;
                        org?: string;
                    };
                    precall_network_information?: {
                        backend_rtt?: number;
                        effective_networktype?: string;
                        fractional_loss?: number;
                        jitter?: number;
                        reflexive_connectivity?: boolean;
                        relay_connectivity?: boolean;
                        rtt?: number;
                        throughput?: number;
                        turn_connectivity?: boolean;
                    };
                };
                quality_stats?: {
                    audio_stats?: Array<{
                        [key: string]: unknown;
                    }>;
                    video_stats?: Array<{
                        [key: string]: unknown;
                    }>;
                    peer_ids?: Array<string>;
                    start?: string | null;
                    end?: string | null;
                    total_audio_packets?: number;
                    total_audio_packets_lost?: number;
                    total_video_packets?: number;
                    total_video_packets_lost?: number;
                    first_audio_packet_received?: string;
                    first_video_packet_received?: string;
                    last_audio_packet_received?: string;
                    last_video_packet_received?: string;
                    average_quality?: number;
                    audio_bandwidth?: number;
                    video_bandwidth?: number;
                };
                peer_report?: {
                    metadata?: {
                        events?: Array<{
                            name?: string;
                            timestamp?: string;
                        }>;
                        pc_metadata?: Array<{
                            effective_network_type?: string;
                            reflexive_connectivity?: boolean;
                            relay_connectivity?: boolean;
                            turn_connectivity?: boolean;
                            timestamp?: string;
                        }>;
                        audio_devices_updates?: Array<{
                            [key: string]: unknown;
                        }>;
                        video_devices_updates?: Array<{
                            [key: string]: unknown;
                        }>;
                        speaker_devices_updates?: Array<{
                            [key: string]: unknown;
                        }>;
                        selected_device_updates?: Array<{
                            [key: string]: unknown;
                        }>;
                        candidate_pairs?: {
                            producing_transport?: Array<{
                                nominated?: boolean;
                                current_round_trip_time?: number;
                                total_round_trip_time?: number;
                                bytes_received?: number;
                                bytes_sent?: number;
                                available_outgoing_bitrate?: number;
                                last_packet_received_timestamp?: number;
                                last_packet_sent_timestamp?: number;
                                local_candidate_id?: string;
                                remote_candidate_id?: string;
                                bytes_discarded_on_send?: number;
                                packets_sent?: number;
                                packets_received?: number;
                                packets_discarded_on_send?: number;
                                local_candidate_type?: string;
                                local_candidate_address?: string;
                                local_candidate_port?: number;
                                local_candidate_protocol?: string;
                                local_candidate_network_type?: string;
                                local_candidate_related_address?: string;
                                local_candidate_related_port?: number;
                                remote_candidate_type?: string;
                                remote_candidate_address?: string;
                                remote_candidate_port?: number;
                                remote_candidate_protocol?: string;
                            }>;
                            consuming_transport?: Array<{
                                [key: string]: unknown;
                            }>;
                        };
                        device_info?: {
                            cpus?: number;
                            is_mobile?: boolean;
                            os?: string;
                            os_version?: string;
                        };
                        browser_metadata?: {
                            browser?: string;
                            browser_version?: string;
                            engine?: string;
                            user_agent?: string;
                            webgl_support?: string;
                        };
                        sdk_name?: string;
                        sdk_version?: string;
                        room_view_type?: string;
                        ip_information?: {
                            city?: string;
                            country?: string;
                            timezone?: string;
                            region?: string;
                            asn?: {
                                asn?: string;
                            };
                            ipv4?: string;
                        };
                    };
                    quality?: {
                        video_consumer?: Array<{
                            [key: string]: unknown;
                        }>;
                        audio_consumer?: Array<{
                            [key: string]: unknown;
                        }>;
                        screenshare_video_consumer?: Array<{
                            [key: string]: unknown;
                        }>;
                        screenshare_audio_consumer?: Array<{
                            [key: string]: unknown;
                        }>;
                        video_producer?: Array<{
                            [key: string]: unknown;
                        }>;
                        audio_producer?: Array<{
                            mos_quality?: number;
                            timestamp?: string;
                            packets_lost?: number;
                            jitter?: number;
                            rtt?: number;
                            packets_sent?: number;
                            bytes_sent?: number;
                            producer_id?: string;
                            ssrc?: number;
                            mid?: string;
                        }>;
                        screenshare_video_producer?: Array<{
                            [key: string]: unknown;
                        }>;
                        screenshare_audio_producer?: Array<{
                            [key: string]: unknown;
                        }>;
                        video_consumer_cumulative?: {
                            [key: string]: unknown;
                        };
                        audio_consumer_cumulative?: {
                            [key: string]: unknown;
                        };
                        screenshare_video_consumer_cumulative?: {
                            [key: string]: unknown;
                        };
                        screenshare_audio_consumer_cumulative?: {
                            [key: string]: unknown;
                        };
                        video_producer_cumulative?: {
                            [key: string]: unknown;
                        };
                        screenshare_video_producer_cumulative?: {
                            [key: string]: unknown;
                        };
                        audio_producer_cumulative?: {
                            quality_mos?: {
                                avg?: number;
                                p50?: number;
                                p75?: number;
                                p90?: number;
                            };
                            packet_loss?: {
                                avg?: number;
                                '50_or_greater_event_fraction'?: number;
                                '25_or_greater_event_fraction'?: number;
                                '10_or_greater_event_fraction'?: number;
                                '5_or_greater_event_fraction'?: number;
                            };
                            rtt?: {
                                avg?: number;
                                '500ms_or_greater_event_fraction'?: number;
                                '250ms_or_greater_event_fraction'?: number;
                                '100ms_or_greater_event_fraction'?: number;
                            };
                        };
                        screenshare_audio_producer_cumulative?: {
                            [key: string]: unknown;
                        };
                    };
                };
            };
        };
    };
};

export type GetParticipantDataFromPeerIdResponse = GetParticipantDataFromPeerIdResponses[keyof GetParticipantDataFromPeerIdResponses];

export type StartTrackRecordingForAMeetingData = {
    /**
     * For now only "default" layer key is supported.
     */
    body?: StartTrackRecordingBody;
    path?: never;
    query?: never;
    url: '/recordings/track';
};

export type StartTrackRecordingForAMeetingResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type ClientOptions = {
    baseUrl: 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | 'https://rtk.realtime.cloudflare.com/v2' | (string & {});
};